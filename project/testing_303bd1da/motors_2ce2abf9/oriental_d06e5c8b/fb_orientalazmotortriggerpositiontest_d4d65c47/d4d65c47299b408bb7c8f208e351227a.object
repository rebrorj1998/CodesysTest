{"payload":{"meta":{"Graph":{"@Type":"81297157","@Value":{"Guid":"(Guid)d4d65c47-299b-408b-b7c8-f208e351227a","ParentGuid":"(Guid)00000000-0000-0000-0000-000000000000","Name":"(string)FB_OrientalAZMotorTriggerPositionTest","Properties":{"@Type":"2c41fa04:IDictionary","@Value":[{"@Key":"(Guid)829a18f2-c514-4f6e-9634-1df173429203","@Value":{"@Type":"829a18f2","@Value":{"ParentObjects":{"@Type":"fa2ee218:IDictionary","@Value":[{"@Key":"(Guid)21af5390-2942-461a-bf89-951aaf6999f1","@Value":"(Guid)d06e5c8b-fb2e-4411-89b5-61785290d938"}]}}}}]},"TypeGuid":"(Guid)6f9dac99-8de1-4efc-8465-68ac443b7d08","EmbeddedTypeGuids":{"@Type":"[Guid]","@Value":["(Guid)a9ed5b7e-75c5-4651-af16-d2c27e98cb94","(Guid)3b83b776-fb25-43b8-99f2-3c507c9143fc"]}}},"TypeInfos":{"2c41fa04":"{2c41fa04-1834-41c1-816e-303c7aa2c05b}","81297157":"{81297157-7ec9-45ce-845e-84cab2b88ade}","829a18f2":"{829a18f2-c514-4f6e-9634-1df173429203}","fa2ee218":"{fa2ee218-a39b-4b6d-b249-49dbddbd168a}","Guid":"System.Guid","string":"System.String"}},"object":{"Graph":{"@Type":"6f9dac99","@Value":{"SpecialFunc":{"@Type":"0db3d7bb:Enum","@Value":"None"},"Implementation":{"@Type":"3b83b776","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)//\tFunction Block: FB_OrientalAZMotor()\n//\tDescription: A PLCOpen Motion compliant library for a Oriental AZ Series drive/motor\n//\t\t\t\t \n//\tCreated by: Ben Hess\n//\tCreated Date: Tuesday, June 2nd 2020\n\n// Outputs for Motion Lib\nPowerState := PowerOn;\nEnableState := DriveEnable;\n\n// Exit if drive isn't enabled.\nIF NOT DriveEnable THEN\n\tError := FALSE;\n\tRETURN;\nEND_IF\n\n// Get raw drive position and alarm code\nIF isGroup THEN\n\tIF __ISVALIDREF(groupMotor0) THEN\n\t\tActPos := groupMotor0.ActPos;\n\t\tenumAlarmCode := groupMotor0.enumAlarmCode;\n\tEND_IF\nELSE\n\tdistanceFromDrive.wWord[0] := modbusDataFromDrive[3];\n\tdistanceFromDrive.wWord[1] := modbusDataFromDrive[2];\n\tActPos := (TO_REAL(distanceFromDrive.diDint) / TO_REAL(stepsPerInchSP)) + zeroOffset;\n\talarmCodeFromDrive.wWord[0] := modbusDataFromDrive[7];\n\talarmCodeFromDrive.wWord[1] := modbusDataFromDrive[6];\n\tenumAlarmCode := TO_INT(alarmCodeFromDrive.diDint);\nEND_IF\nalarmCode := TO_DWORD(enumAlarmCode);\n\n// Pack RIO to write to drive\npackedRIO.dDword.0 := homeSwitchTrigger;\npackedRIO.dDword.1 := homeNow;\npackedRIO.dDword.2 := P_Preset;\npackedRIO.dDword.3 := start;\npackedRIO.dDword.4 := zHome;\npackedRIO.dDword.5 := stop;\npackedRIO.dDword.6 := freeMotor;\npackedRIO.dDword.7 := reset;\npackedRIO.dDword.12 := EL_Preset;\npackedRIO.dDword.13 := jogReverse;\npackedRIO.dDword.14 := jogForward;\nmodbusRIODataToDrive[0] := packedRIO.wWord[1];\nmodbusRIODataToDrive[1] := packedRIO.wWord[0];\n\n// Setup delay timers\ndelayTimer(IN := state = eOrientalAZDriveStates.DelayAfterWrite);\nzHomeDelay(IN := state = eOrientalAZDriveStates.Homing);\npresetDelay(IN := state = eOrientalAZDriveStates.SettingPreset);\n// Trigger an RIO write whenever it changes\nIF packedRIO.dDword <> packedRIOLast AND NOT triggerRIOWriteNow THEN\n\tpackedRIOLast := packedRIO.dDword;\n\ttriggerRIOWriteNow := TRUE;\nEND_IF\nresetRIOWrite(IN := triggerRIOWriteNow);\nIF resetRIOWrite.Q THEN\n\ttriggerRIOWriteNow := FALSE;\nEND_IF\npositionPresetONS(CLK := positionPresetRequest);\n\n// Only set comm error status after x modbus errors\ncommErrorONS(CLK := MBChannel.xError);\nIF commErrorONS.OSR THEN\n\tcommErrorCount := commErrorCount + 1;\nEND_IF\ncommErrorFaultONS(CLK := commErrorCount = commErrorFaultSetting);\nIF NOT isGroup THEN\n\tIF commErrorFaultONS.OSR THEN\n\t\tstate := eOrientalAZDriveStates.Faulting;\n\t\tCommStatus := FALSE;\n\tEND_IF\nEND_IF\t\n\n// Get drive data directly from modbus or from master axis\t\nIF isGroup THEN\n\tIF __ISVALIDREF(groupMotor0) AND __ISVALIDREF(groupMotor1) THEN\n\t\tready := groupMotor0.ready AND groupMotor1.ready;\n\t\talarmActive := groupMotor0.alarmActive OR groupMotor1.alarmActive;\n\t\tmoving := groupMotor0.moving AND groupMotor1.moving;\n\t\tinPosition := groupMotor0.inPosition AND groupMotor1.inPosition;\n\t\tatTorqueLimit := groupMotor0.atTorqueLimit OR groupMotor1.atTorqueLimit;\n\tEND_IF\nELSE\n\tReady := modbusDataFromDrive[5].5;\n\tAlarmActive := modbusDataFromDrive[5].7;\n\tMoving := modbusDataFromDrive[5].13;\n\tInPosition := modbusDataFromDrive[5].14;\n\tAtTorqueLimit := modbusDataFromDrive[5].15;\nEND_IF\n\n// Halt motor when Halt command seen\nhaltONS(CLK := Halt);\nIF haltONS.OSR THEN\n\tstate := eOrientalAZDriveStates.Halt;\nEND_IF\n\ntriggerPositonPreset(CLK := positionPresetRequest);\nfreeMotorRequestONS(CLK := freeMotorRequest);\n\n// Reset motor when AckError command seen\nIF AckError THEN\n\tstate := eOrientalAZDriveStates.Resetting;\nEND_IF\nalarmActiveONS(clk:= alarmActive);\nIF alarmActiveONS.OSR THEN\n\tstate := eOrientalAZDriveStates.Faulting;\nEND_IF\n\n// Main motor state machine\nCASE state OF\n\teOrientalAZDriveStates.Idle:\n\t\n\t\t\t\t// \tIdle state, wait for command\n\t\t\t\tIF MoveAbs THEN\n\t\t\t\t\tfreeMotor := FALSE;\n\t\t\t\t\tTargetReached := FALSE;\n\t\t\t\t\tAxisState := AXIS_STATE.AS_DiscreteMotion;\n\t\t\t\t\tstate := eOrientalAZDriveStates.MoveABS;\n\t\t\t\tELSIF MoveRel THEN\n\t\t\t\t\tfreeMotor := FALSE;\n\t\t\t\t\tTargetReached := FALSE;\n\t\t\t\t\tAxisState := AXIS_STATE.AS_DiscreteMotion;\n\t\t\t\t\tstate := eOrientalAZDriveStates.MoveInc;\n\t\t\t\tELSIF MoveAbsTorque THEN\n\t\t\t\t\tfreeMotor := FALSE;\n\t\t\t\t\tTargetReached := FALSE;\n\t\t\t\t\tAxisState := AXIS_STATE.AS_DiscreteMotion;\n\t\t\t\t\tstate := eOrientalAZDriveStates.MovePush;\n\t\t\t\tELSIF jogForwardCMD OR jogReverseCMD THEN\n\t\t\t\t\tstate := eOrientalAZDriveStates.Jogging;\n\t\t\t\tELSIF StartHoming THEN\n\t\t\t\t\tfreeMotor := FALSE;\n\t\t\t\t\tHomingDone := FALSE;\n\t\t\t\t\t//AxisState := AXIS_STATE.AS_Homing;\n\t\t\t\t\tstate := eOrientalAZDriveStates.Home;\n\t\t\t\tELSIF triggerPositonPreset.OSR THEN\n\t\t\t\t\tstate := eOrientalAZDriveStates.SetPreset;\n\t\t\t\tEND_IF\n\t\t\t\tIF MBChannel.xDone OR isGroup THEN\n\t\t\t\t\tCommStatus := TRUE;\n\t\t\t\t\tcommErrorCount := 0;\n\t\t\t\tEND_IF\n\n\teOrientalAZDriveStates.MoveABS:\n\t\t\t\t// Move to absolute position\n\t\t\t\tdirectDataOp.OperationType.diDint := eOrientalOperationType.Absolute_Positioning;\n\t\t\t\tdirectDataOp.Position.diDint := mDistanceCalc(TargetPosDist);\n\t\t\t\tdirectDataOp.Speed.diDint := mVeloAccDecCalc(ProfileVelocity);\n\t\t\t\tdirectDataOp.RateOfChange.diDint := mVeloAccDecCalc(ProfileAcceleration);\n\t\t\t\tdirectDataOp.StoppingDecel.diDint := mVeloAccDecCalc(ProfileDeceleration);\n\t\t\t\tdirectDataOp.Current.diDint := mCurrentCalc(DefaultCurrent);\n\t\t\t\tdirectDataOp.Trigger.diDint := 1;\n\t\t\t\tmPackDDOp();\n\t\t\t\ttriggerDDWriteNow := TRUE;\n\t\t\t\tstate := eOrientalAZDriveStates.DelayAfterWrite;\n\t\t\t\tnextState := eOrientalAZDriveStates.Moving;\n\t\t\t\t\n\t\t\t\t\n\t\t\n\teOrientalAZDriveStates.MovePush:\n\t\n\t\t\t\t// Move to absolute position \"push\" (at a limited current)\n\t\t\t\tdirectDataOp.OperationType.diDint := eOrientalOperationType.Absolute_Push;\n\t\t\t\tdirectDataOp.Position.diDint := mDistanceCalc(TargetPosDist);\n\t\t\t\tdirectDataOp.Speed.diDint := mVeloAccDecCalc(ProfileVelocity);\n\t\t\t\tdirectDataOp.RateOfChange.diDint := mVeloAccDecCalc(ProfileAcceleration);\n\t\t\t\tdirectDataOp.StoppingDecel.diDint := mVeloAccDecCalc(ProfileDeceleration);\n\t\t\t\tdirectDataOp.Current.diDint := mCurrentCalc(ProfileCurrentLimit);\n\t\t\t\tdirectDataOp.Trigger.diDint := 1;\n\t\t\t\tmPackDDOp();\n\t\t\t\ttriggerDDWriteNow := TRUE;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tstate := eOrientalAZDriveStates.DelayAfterWrite;\n\t\t\t\tnextState := eOrientalAZDriveStates.Moving;\n\t\t\t\t\n\t\t\t\t\n\t\teOrientalAZDriveStates.MoveInc:\n\t\t\n\t\t\t\t// Move to incremental position\n\t\t\t\tdirectDataOp.OperationType.diDint := eOrientalOperationType.Incremental_Positioning;\n\t\t\t\tdirectDataOp.Position.diDint := mDistanceCalc(TargetPosDist);\n\t\t\t\tdirectDataOp.Speed.diDint := mVeloAccDecCalc(ProfileVelocity);\n\t\t\t\tdirectDataOp.RateOfChange.diDint := mVeloAccDecCalc(ProfileAcceleration);\n\t\t\t\tdirectDataOp.StoppingDecel.diDint := mVeloAccDecCalc(ProfileDeceleration);\n\t\t\t\tdirectDataOp.Current.diDint := mCurrentCalc(DefaultCurrent);\n\t\t\t\tdirectDataOp.Trigger.diDint := 1;\n\t\t\t\tmPackDDOp();\n\t\t\t\ttriggerDDWriteNow := TRUE;\n\t\t\t\t\n\t\t\t\tstate := eOrientalAZDriveStates.DelayAfterWrite;\n\t\t\t\tnextState := eOrientalAZDriveStates.Moving;\n\t\t\t\t\n\t\teOrientalAZDriveStates.Home:\n\t\t\t\t// Home motor\n\t\t\t\tzHome := TRUE;\n\t\t\t\tstate := eOrientalAZDriveStates.DelayAfterWrite;\n\t\t\t\tnextState := eOrientalAZDriveStates.Homing;\n\t\t\t\t\n\t\t\n\t\teOrientalAZDriveStates.Homing:\t\t\n\t\t\t\t// Wait until ZHome is done\n\t\t\t\tIF zHomeDelay.Q AND TO_DINT(ActPos * 1000) >= (TO_DINT(zeroOffset * 1000) - 10) AND TO_DINT(ActPos * 1000) <= (TO_DINT(zeroOffset * 1000) + 10) THEN\n\t\t\t\t\tzHome := FALSE;\n\t\t\t\t\tHomingDone := TRUE;\n\t\t\t\t\tstate := eOrientalAZDriveStates.DoneMoving;\n\t\t\t\tEND_IF\n\t\t\t\t\n\t\teOrientalAZDriveStates.Jogging:\n\t\t\t\t// Jog forward/reverse\n\t\t\t\tjogForward := jogForwardCMD;\n\t\t\t\tjogReverse := jogReverseCMD;\n\t\t\t\t\n\t\t\t\tIF NOT jogForward AND NOT jogReverse THEN\n\t\t\t\t\tstate := eOrientalAZDriveStates.Idle;\n\t\t\t\tEND_IF\n\t\t\n\t\teOrientalAZDriveStates.SetPreset:\t\t\n\t\t\t\t// Set factory ZERO preset\n\t\t\t\tfreeMotor := TRUE;\n\t\t\t\t//P_Preset := TRUE;\n\t\t\t\tIF triggerPositonPreset.OSF THEN\n\t\t\t\t\tstate := eOrientalAZDriveStates.SettingPreset;\n\t\t\t\tEND_IF\n\t\t\n\t\teOrientalAZDriveStates.SettingPreset:\n\t\t\t\t// Set factory zero preset on AZ Motor\n\t\t\t\tP_Preset := TRUE;\n\t\t\t\tIF distanceFromDrive.dDword = 0 OR presetDelay.Q THEN\n\t\t\t\t\tfreeMotor := FALSE;\n\t\t\t\t\tP_Preset := FALSE;\n\t\t\t\t\tstate := eOrientalAZDriveStates.Idle;\n\t\t\t\tEND_IF\n\t\t\t\t\n\t\teOrientalAZDriveStates.SetPresetDone:\n\t\t\t\t//\n\t\teOrientalAZDriveStates.DelayAfterWrite:\n\t\t\t\t// A small delay before moving on to next state\n\t\t\t\tIF delayTimer.Q THEN\n\t\t\t\t\ttriggerDDWriteNow := FALSE;\n\t\t\t\t\tstate := nextState;\n\t\t\t\tEND_IF\n\t\t\n\t\teOrientalAZDriveStates.Moving:\n\t\t\t\t// After sending data, we are moving\n\t\t\t\tIF (mInPosition() AND (MoveAbs OR MoveAbsTorque)) OR (atTorqueLimit AND MoveAbsTorque) OR (inPosition AND MoveRel) THEN\n\t\t\t\t\tTargetReached := TRUE;\n\t\t\t\t\tstate := eOrientalAZDriveStates.DoneMoving;\n\t\t\t\tEND_IF\n\t\t\n\t\teOrientalAZDriveStates.DoneMoving:\n\t\t\t\t// Wait for status to clear\n\t\t\t\tIF NOT MoveAbs AND NOT MoveAbsTorque AND NOT MoveRel AND NOT StartHoming THEN\n\t\t\t\t\tAxisState := AXIS_STATE.AS_Standstill;\n\t\t\t\t\tstate := eOrientalAZDriveStates.Idle;\n\t\t\t\tEND_IF \n\n\t\teOrientalAZDriveStates.Halt:\n\t\t\t\t// \n\t\t\t\tfreeMotor := TRUE;\n\t\t\t\tAxisState := AXIS_STATE.AS_ErrorStop;\n\t\t\t\tstate := eOrientalAZDriveStates.Halted;\n\t\t\t\t\n\t\teOrientalAZDriveStates.Halted:\n\t\t\t\t// \n\t\t\t\tIF AckError THEN\n\t\t\t\t\tstate := eOrientalAZDriveStates.Resetting;\n\t\t\t\t\tfreeMotor := FALSE;\n\t\t\t\tEND_IF\n\t\t\t\t\n\t\t\t\t\n\t\teOrientalAZDriveStates.Faulting:\n\t\t\t\t// Faulting - stop drive\n\t\t\t\tmClearStatus();\n\t\t\t\tAxisState := AXIS_STATE.AS_ErrorStop;\n\t\t\t\tError := TRUE;\n\t\t\t\tfreeMotor := TRUE;\n\t\t\t\tzHome := FALSE;\n\t\t\t\t//triggerRIOWriteNow := TRUE;\n\t\t\t\tstate := eOrientalAZDriveStates.Faulted;\n\t\t\t\t\n\t\teOrientalAZDriveStates.Faulted:\n\t\t\t\t// Faulted - wait for clear\n\t\t\t\tIF AckError THEN\n\t\t\t\t\tstate := eOrientalAZDriveStates.Resetting;\n\t\t\t\tEND_IF\n\t\t\n\t\teOrientalAZDriveStates.Resetting:\n\t\t\t\t// \n\t\t\t\t\tCommStatus := TRUE;\n\t\t\t\t\tcommErrorCount := 0;\n\t\t\t\t\tIF alarmActive THEN\n\t\t\t\t\t\treset := TRUE;\n\t\t\t\t\tEND_IF\n\t\t\t\t\tIF NOT alarmActive THEN\n\t\t\t\t\t\ttriggerDDWriteNow := FALSE;\n\t\t\t\t\t\ttriggerRIOWriteNow := FALSE;\n\t\t\t\t\t\tAckError := FALSE;\n\t\t\t\t\t\tError := FALSE;\n\t\t\t\t\t\tfreeMotor := FALSE;\n\t\t\t\t\t\treset := FALSE;\n\t\t\t\t\t\tzHome := FALSE;\n\t\t\t\t\t\tMoveAbs := FALSE;\n\t\t\t\t\t\tMoveRel := FALSE;\n\t\t\t\t\t\tMoveAbsTorque := FALSE;\n\t\t\t\t\t\tStartHoming := FALSE;\n\t\t\t\t\t\tstate := eOrientalAZDriveStates.Idle;\n\t\t\t\t\t\tnextState := eOrientalAZDriveStates.Idle;\n\t\t\t\t\tEND_IF\nEND_CASE\n\n","LineInfoPersistence":"(string)d4d65c47-299b-408b-b7c8-f208e351227a_Impl_LineIds"}}}},"Interface":{"@Type":"a9ed5b7e","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)FUNCTION_BLOCK FB_OrientalAZMotorTriggerPositionTest EXTENDS Axis_REF\nVAR_INPUT\n\t// Set this flag if this motor is actually a group\n\tisGroup : BOOL;\n\t// Steps per inch of motion\n\tstepsPerInchSP : DINT := 3999;\n\t// At factory \"zero\" there can be an offset\n\tzeroOffset : REAL;\n\t// Jog motor forward command\n\tjogForwardCMD : BOOL;\n\t// Jog motor reverse command\n\tjogReverseCMD : BOOL;\n\t// Factory \"zero\" positon preset command\n\tpositionPresetRequest : BOOL;\n\t// Free up motor command\n\tfreeMotorRequest : BOOL;\n\t// Ref to Master Motor if group\n\tgroupMotor0 : REFERENCE TO FB_OrientalAZMotorTriggerPositionTest;\n\t// Ref to Slave Motor if group\n\tgroupMotor1 : REFERENCE TO FB_OrientalAZMotorTriggerPositionTest;\t\nEND_VAR\nVAR_OUTPUT\n\t// Hex alarm code reported from AZ Drive\n\talarmCode : DWORD;\n\t// Trigger direct data write through modbus\n\ttriggerDDWriteNow : BOOL;\n\t// Trigger Remote I/O data write through modbus\n\ttriggerRIOWriteNow : BOOL;\nEND_VAR\nVAR\n\tdirectDataOp : sctOrientalDirectData;\n\tdistanceFromDrive : uModbusDWORD;\n\talarmCodeFromDrive : uModbusDWORD;\n\tready : BOOL;\n\talarmActive : BOOL;\n\tmoving : BOOL;\n\tinPosition : BOOL;\n\tatTorqueLimit : BOOL;\n\tatPosition : BOOL;\n\thomeSwitchTrigger : BOOL;\n\thomeNow : BOOL;\n\tP_Preset : BOOL;\n\tstart : BOOL;\n\tzHome : BOOL;\n\tstop : BOOL;\n\tfreeMotor : BOOL;\n\treset : BOOL;\n\tEL_Preset : BOOL;\n\tjogReverse : BOOL;\n\tjogForward : BOOL;\n\tpackedRIO : uModbusDWORD;\n\tpackedRIOLast : DWORD;\n\tdelayTimer : Standard.TON := (PT := T#50MS);\n\tzHomeDelay : Standard.TON := (PT := T#250MS);\n\tpresetDelay : Standard.TON := (PT := T#200MS);\n\tmodbusWriteResponse : ARRAY[0..20] OF WORD;\n\treadAfterDDWrite : FB_ONS;\n\treadAfterRIOWrite : FB_ONS;\n\ttriggerPositonPreset : FB_ONS;\n\thaltONS : FB_ONS;\n\talarmActiveONS : FB_ONS;\n\tfreeMotorRequestONS : FB_ONS;\n\ttriggerRIOWrite : BOOL;\n\tresetRIOWrite : Standard.TON := (PT := T#50MS);\n\tdisable : BOOL;\n\tenumAlarmCode : eOrientalAZDriveFaults;\n\tstate : eOrientalAZDriveStates;\n\tnextState : eOrientalAZDriveStates;\n\tcommErrorONS : FB_ONS;\n\tcommErrorFaultONS : FB_ONS;\n\tcommErrorCount : DINT;\n\tcommErrorFaultSetting : DINT := 3;\n\tpositionPresetONS : FB_ONS;\nEND_VAR\nVAR_IN_OUT\n\tMBChannel : IoDrvModbus.ModbusSlaveComPort;\n\tmodbusDataFromDrive : ARRAY[0..39] OF WORD;\n\tmodbusDirectDataToDrive : ARRAY[0..16] OF WORD;\n\tmodbusRIODataToDrive : ARRAY[0..1] OF WORD;\nEND_VAR","LineInfoPersistence":"(string)d4d65c47-299b-408b-b7c8-f208e351227a_Decl_LineIds"}}}},"UniqueIdGenerator":"(string)2673","POULevel":{"@Type":"8e575c5b:Enum","@Value":"Standard"},"ChildObjectGuids":{"@Type":"ArrayList:IList","@Value":[]},"AddAttributeSubsequent":"(bool)False"}},"TypeInfos":{"0db3d7bb":"{0db3d7bb-cde0-4416-9a7b-ce49a0124323}","3b83b776":"{3b83b776-fb25-43b8-99f2-3c507c9143fc}","6f9dac99":"{6f9dac99-8de1-4efc-8465-68ac443b7d08}","8e575c5b":"{8e575c5b-1d37-49c6-941b-5c0ec7874787}","a9ed5b7e":"{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}","ArrayList":"System.Collections.ArrayList","bool":"System.Boolean","f3878285":"{f3878285-8e4f-490b-bb1b-9acbb7eb04db}","string":"System.String"}}},"FormatVersion":"1.0"}