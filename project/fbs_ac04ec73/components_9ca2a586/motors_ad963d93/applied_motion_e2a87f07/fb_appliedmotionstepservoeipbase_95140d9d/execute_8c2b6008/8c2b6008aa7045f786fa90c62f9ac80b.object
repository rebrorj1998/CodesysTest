{"payload":{"meta":{"Graph":{"@Type":"81297157","@Value":{"Guid":"(Guid)8c2b6008-aa70-45f7-86fa-90c62f9ac80b","ParentGuid":"(Guid)95140d9d-e31a-4eb2-a5f3-024ab52351fa","Name":"(string)Execute","Properties":{"@Type":"2c41fa04:IDictionary","@Value":{}},"TypeGuid":"(Guid)f8a58466-d7f6-439f-bbb8-d4600e41d099","EmbeddedTypeGuids":{"@Type":"[Guid]","@Value":["(Guid)a9ed5b7e-75c5-4651-af16-d2c27e98cb94","(Guid)3b83b776-fb25-43b8-99f2-3c507c9143fc"]}}},"TypeInfos":{"2c41fa04":"{2c41fa04-1834-41c1-816e-303c7aa2c05b}","81297157":"{81297157-7ec9-45ce-845e-84cab2b88ade}","Guid":"System.Guid","string":"System.String"}},"object":{"Graph":{"@Type":"f8a58466","@Value":{"Implementation":{"@Type":"3b83b776","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)//    Function Block: AppliedMotionStepServo\n//    Description: This block provides an abstraction for a Ethernet I/P Applied Motion Step Servo\n//    Created by: Ben Hess\n//    Created Date: May 11th, 2018\n\n// Use pointers for EIP memory register locations\ndriveInputs := ptrEIPInputs^;\n// Step servo command bits handler\ncommands();\nptrEIPOutputs^ := driveOutputs;\nalarms(alarmCode := stepServoAlarmCodeRaw, faults := faults);\n\nIF currentLimit = 0 THEN \n\tcurrentLimit := defaultCurrentSetpoint;\nEND_IF\n//Map raw EIP Registers to parameters\nIF feedbackSelection = PositionFeedbackSelection.EncoderPosition THEN\n\tabsolutePositionSteps := driveInputs[5];\nELSE\n\tabsolutePositionSteps := driveInputs[6];\nEND_IF\n\nvelocity := DINT_TO_INT(driveInputs[8]);\nstepServoStatusRaw := DINT_TO_INT(driveInputs[0]);\nstepServoAlarmCodeRaw := DINT_TO_INT(driveInputs[1]);\ndriveOutputs[4] := velocitySetpoint;\ndriveOutputs[5] := pointToPointAccelSetpoint;\ndriveOutputs[6] := pointToPointDecelSetpoint;\ndriveOutputs[7] := distanceToMoveInSteps;\ndriveOutputs[8] := currentLimit;\ndriveOutputs[9] := sclCommand;\ndriveOutputs[10] := parameter1;\ndriveOutputs[11] := parameter2;\ndriveOutputs[12] := currentLimit;\ndriveOutputs[13] := currentLimit;\ndriveOutputs[0] := commands.commandWord;\n\n//Convert Distance setpoint to steps.  Reverse polarity for display purposes if needed. \n\nabsolutePositonInches := (DINT_TO_REAL(absolutePositionSteps) / INT_TO_REAL(stepsPerInchSetpoint));\n\n//Homing required from motor - for now just if there was an initialization seen.\nhomeRequiredIndication S= status.initializing OR Globals.firstScan OR _faulted OR driveInputs[11].0;\n//homeRequiredIndication S= status.initializing OR Globals.firstScan OR driveInputs[11].0;\nhomingOSF(CLK := status.homing);\nIF NOT driveInputs[11].0 THEN\n\thomeRequiredIndication := FALSE;\nEND_IF\n\ncommandSentONS(CLK := commands.commandSent);\n\nIF commandSentONS.Q THEN\n\tcommandSuccessful := TRUE;\nEND_IF\n\ncommandSuccessfulONS(CLK := commandSuccessful);\nIF commandSuccessfulONS.Q THEN\n\t//parameter1 := 0;\n\t//velocitySetpoint := 0;\n\t//pointToPointAccelSetpoint := 0;\n\t//pointToPointDecelSetpoint := 0;\n\t//distanceToMoveInSteps := 0;\nEND_IF\n\nresetTimeout(IN := _reset, PT := T#1S);\nencoderResetTimeout(PT := T#150MS);\nIF resetTimeout.Q THEN\n\tresetState := 0;\n\tencoderResetTimeout.IN := FALSE;\n\t_reset := FALSE;\nEND_IF\nCASE resetState OF\n\t\n\t0 :\t\t// Do Nothing\n\t\t\tIF _reset THEN\n\t\t\t\tresetState := 1;\n\t\t\tEND_IF\n\t1 :\t\t// \n\t\t\tcommandSuccessful := FALSE;\n\t\t\tcommands.alarmReset := TRUE;\n\t\t\tresetState := 2;\n\t\n\t2 :\t\tIF commandSuccessful THEN\n\t\t\t\tcommandSuccessful := FALSE;\n\t\t\t\tcommands.Enable := TRUE;\n\t\t\t\tresetState := 3;\t\t\n\t\t\tEND_IF\n\t\n\t3 :\t\t//\n\t\t\tIF commandSuccessful THEN;\n\t\t\t\tencoderResetTimeout.IN := TRUE;\n\t\t\t\tIF encoderResetTimeout.Q THEN\n\t\t\t\t\tresetState := 4;\t\n\t\t\t\t\t//ResetEncoderPosition(driveInputs[5]);\t\n\t\t\t\tEND_IF\n\t\t\tEND_IF\n\t\n\t4 :\t\t//\n\t\t\tIF commandSuccessful THEN;\n\t\t\t\tresetState := 0;\n\t\t\t\t_reset := FALSE;\n\t\t\tEND_IF\nEND_CASE\n\nIF reversePolarity THEN\n    absolutePositonInches := absolutePositonInches * -1; \nEND_IF\nabsolutePositonInches := absolutePositonInches + positionOffset;\n\n//Get Servo Status and unpack\nstatus(statusCode := StepServoStatusRaw);\n\n//Bit-packing for LONG types over Modbus\n//_faulted := status.driveFaulted OR status.alarmPresent OR commFail;\n_faulted := status.driveFaulted OR commFail;\n\n//Manual moves for motor\nIF moveDistanceManualPB THEN\n    MoveDistance(distance := distanceSetpointInches, acceleration := pointToPointAccelSetpoint, deceleration := pointToPointDecelSetpoint, velocity := velocitySetpoint);\n    moveDistanceManualPB := FALSE;\nEND_IF\n\nIF movePositionManualPB THEN\n    MoveToPosition(position := distanceSetpointInches, acceleration := pointToPointAccelSetpoint, deceleration := pointToPointDecelSetpoint, velocity := velocitySetpoint);\n    movePositionManualPB := FALSE;\nEND_IF\n\n\nfaults.commFail.faultTrigger := commFail; //AND Globals.machinePowerOK;\n//faults.notHomed.faultTrigger := homeRequiredIndication AND isHomable;\n\n","LineInfoPersistence":"(string)8c2b6008-aa70-45f7-86fa-90c62f9ac80b_Impl_LineIds"}}}},"Interface":{"@Type":"a9ed5b7e","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)METHOD Execute\nVAR_INPUT\nEND_VAR\n","LineInfoPersistence":"(string)8c2b6008-aa70-45f7-86fa-90c62f9ac80b_Decl_LineIds"}}}}}},"TypeInfos":{"3b83b776":"{3b83b776-fb25-43b8-99f2-3c507c9143fc}","a9ed5b7e":"{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}","f3878285":"{f3878285-8e4f-490b-bb1b-9acbb7eb04db}","f8a58466":"{f8a58466-d7f6-439f-bbb8-d4600e41d099}","string":"System.String"}}},"FormatVersion":"1.0"}