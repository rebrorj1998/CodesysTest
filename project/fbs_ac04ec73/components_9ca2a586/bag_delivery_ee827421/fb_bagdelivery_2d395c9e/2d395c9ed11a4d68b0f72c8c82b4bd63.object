{"payload":{"meta":{"Graph":{"@Type":"81297157","@Value":{"Guid":"(Guid)2d395c9e-d11a-4d68-b0f7-2c8c82b4bd63","ParentGuid":"(Guid)00000000-0000-0000-0000-000000000000","Name":"(string)FB_BagDelivery","Properties":{"@Type":"2c41fa04:IDictionary","@Value":[{"@Key":"(Guid)829a18f2-c514-4f6e-9634-1df173429203","@Value":{"@Type":"829a18f2","@Value":{"ParentObjects":{"@Type":"fa2ee218:IDictionary","@Value":[{"@Key":"(Guid)21af5390-2942-461a-bf89-951aaf6999f1","@Value":"(Guid)ee827421-e338-473f-9145-9cd2304f14ef"}]}}}}]},"TypeGuid":"(Guid)6f9dac99-8de1-4efc-8465-68ac443b7d08","EmbeddedTypeGuids":{"@Type":"[Guid]","@Value":["(Guid)a9ed5b7e-75c5-4651-af16-d2c27e98cb94","(Guid)3b83b776-fb25-43b8-99f2-3c507c9143fc"]}}},"TypeInfos":{"2c41fa04":"{2c41fa04-1834-41c1-816e-303c7aa2c05b}","81297157":"{81297157-7ec9-45ce-845e-84cab2b88ade}","829a18f2":"{829a18f2-c514-4f6e-9634-1df173429203}","fa2ee218":"{fa2ee218-a39b-4b6d-b249-49dbddbd168a}","Guid":"System.Guid","string":"System.String"}},"object":{"Graph":{"@Type":"6f9dac99","@Value":{"SpecialFunc":{"@Type":"0db3d7bb:Enum","@Value":"None"},"Implementation":{"@Type":"3b83b776","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)//    Function Block: BagDeliveryFB\n//    Description: This is the state machine for the bag delivery test rig\n//    \n//    Created by: Ben Hess\n//    Created Date: Thursday, April 19, 2018\n\nSUPER^();\nIF _testTorqueNow THEN\n\tbagFeedRearMotor.SetTorque(_testTorqueValue);\n\t_testTorqueNow := FALSE;\nEND_IF\n//\nIF enableONS.Q OR resetONS.Q THEN\n    _reset := FALSE;\n\tstate := BAG_DELIVERY_STATES.Reset;\nEND_IF\n\n//\n_delayTimer();\n\n//\n_delayForReverseFault();\n\n//\n_autoFeedDelay(IN := _amFeedBagOut);\n\n//\n_sealBarToPrintHeadLength := ABS(_reverseToPrintHeadSetpoint) + 2.25;\n\n//\nIF (HMIData.baggerModelSelection = ModelSelection.Pro18_1174) OR \n   (HMIData.baggerModelSelection = ModelSelection.Pro18_1183) THEN\n\t_reverseToPrintHeadSetpoint := -1.25;\nELSE\n\t_reverseToPrintHeadSetpoint := -1.0;\nEND_IF\n\n//\nbagFeedMasterMotor(\n\tptrEIPInputs := ADR(bagDeliveryMotorInputs),\n    ptrEIPOutputs := ADR(bagDeliveryMotorOutputs),\n\tinterconnect := _interconnect,\n\tplacement := BAG_DELIVERY_MOTOR_PLACEMENT.Front,\n    stepsPerInchSetpoint := stepsPerInchSetting,\n\treversePolarity := FALSE, \n\tdefaultCurrentSetpoint := 1150, \n\tcommFail := bagFeedMasterMotorCommFailInput\n);\nbagFeedMasterMotor.Execute();\n\n//\nbagFeedRearMotor(\n\tptrEIPInputs := ADR(bagRearMotorInputs),\n    ptrEIPOutputs := ADR(bagRearMotorOutputs),\n\tinterconnect := _interconnect,\n\tplacement := BAG_DELIVERY_MOTOR_PLACEMENT.Rear,\n    stepsPerInchSetpoint := stepsPerInchSetting,\n\tdefaultCurrentSetpoint := 1150, \n\tcommFail := bagFeedRearMotorCommFailInput\n);\nbagFeedRearMotor.Execute();\n\n//\nCASE rearMotorConfigVersion OF\n\tCONFIG_VERSIONS.V_1_0,\n\tCONFIG_VERSIONS.V_1_1:\n\t\t_interconnect := BAG_DELIVERY_IC.CBL;\n\t\t_tensionFault := iBagTensionFault;\n\t\tbagFeedRearMotor.reversePolarity := FALSE;\n\tCONFIG_VERSIONS.V_1_2, \n\tCONFIG_VERSIONS.V_1_3:\n\t\t_interconnect := BAG_DELIVERY_IC.EIP;\n\t\t_tensionFault := bagFeedRearMotor.tensionFault;\n\t\tbagFeedRearMotor.reversePolarity := TRUE;\nEND_CASE\n\n//\nbagTensionFault.faultTrigger := _tensionFault AND NOT HMIData.enableDryCycle;\n\n//\nIF NOT enable THEN\n    state := BAG_DELIVERY_STATES.Idle;\nEND_IF\n\n//\n_syncingONS(CLK := state = BAG_DELIVERY_STATES.Sync);\nIF _syncingONS.Q THEN\n\tbagFeedMasterMotor.ack := FALSE;\n\tbagFeedRearMotor.ack := FALSE;\nEND_IF\n\n//\n_jogForwardONS(CLK := jogForwardPB);\n_jogReverseONS(CLK := jogReversePB);\n \n//\nIF state = BAG_DELIVERY_STATES.Idle OR state = BAG_DELIVERY_STATES.Ready THEN\n\tIF _jogForwardONS.Q THEN\n\t\t_jogging := TRUE;\n\t\tbagFeedMasterMotor.MoveDistance(\n\t\t\tdistance := 30, \n\t\t\tacceleration := accelSetpoint, \n\t\t\tdeceleration := decelSetpoint, \n\t\t\tvelocity := REAL_TO_INT((1 * velocityMultiplier))\n\t\t);\n\t\tbagFeedRearMotor.MoveDistance(\n\t\t\tdistance := 30, \n\t\t\tacceleration := accelSetpoint, \n\t\t\tdeceleration := decelSetpoint, \n\t\t\tvelocity := REAL_TO_INT((1 * velocityMultiplier))\n\t\t);\t\t\t\t\t\t\t\t\t\t\n\tELSIF _jogReverseONS.Q THEN\n\t\t_jogging := TRUE;\n\t\tbagFeedMasterMotor.MoveDistance(\n\t\t\tdistance := -30, \n\t\t\tacceleration := accelSetpoint, \n\t\t\tdeceleration := decelSetpoint, \n\t\t\tvelocity := REAL_TO_INT((1 * velocityMultiplier))\n\t\t);\n\t\tbagFeedRearMotor.MoveDistance(\n\t\t\tdistance := -30, \n\t\t\tacceleration := accelSetpoint, \n\t\t\tdeceleration := decelSetpoint, \n\t\t\tvelocity := REAL_TO_INT((1 * velocityMultiplier))\n\t\t);\n\tEND_IF\n\t\n\t//\n\tIF (bagFeedMasterMotor.status.moving) AND NOT jogForwardPB AND NOT jogReversePB THEN\n\t\t_jogging := FALSE;\n\t\tbagFeedMasterMotor.Stop();\n\t\tbagFeedRearMotor.Stop();\n\t\tbagFeedMasterMotor.Reset();\n\t\tbagFeedRearMotor.Reset();\n\tEND_IF\t\nEND_IF\n\n//\nIF _jogging THEN\n\tIF bagFeedMasterMotor.ackRequest AND bagFeedRearMotor.ackRequest THEN\n\t\tbagFeedMasterMotor.ack := TRUE;\n\t\tbagFeedRearMotor.ack := TRUE;\n\tEND_IF\nEND_IF\n\n//\n_ready := (_mode = DEVICE_MODES.Auto) AND (NOT (state = BAG_DELIVERY_STATES.Fault) OR NOT (state = BAG_DELIVERY_STATES.Idle));\n\n//\nCASE state OF\n\t\tBAG_DELIVERY_STATES.Reset:\n\t\t\t\n\t\tbagFeedRearMotor.Reset();\n\t\tbagFeedMasterMotor.Reset();\n\t\t_nextState := BAG_DELIVERY_STATES.Idle; \n\t\tstate := BAG_DELIVERY_STATES.Resetting;\n\t\t\n\t\tClearCommands();\n\t\n\tBAG_DELIVERY_STATES.Resetting:\n\t\tIF bagFeedRearMotor.resetState = 0 THEN\n\t\t\tstate := BAG_DELIVERY_STATES.SetTorqueMode;\n\t\tEND_IF\n\t\n    BAG_DELIVERY_STATES.Idle:\n\t\t\n\t\t//                     \n\t\tIF _mode = DEVICE_MODES.Manual THEN \n\t\t\tstate := BAG_DELIVERY_STATES.Manual;\n\t\tELSIF NOT iBagNotPresent OR HMIData.enableDryCycle THEN\n\t\t\tstate := BAG_DELIVERY_STATES.Ready;\n\t\tELSIF (_amFeedToEye OR _amReverseBag) THEN\n\t\t\t_amFeedToEye := FALSE;\n\t\t\tstate := BAG_DELIVERY_STATES.FeedToEye;\n\t\tELSIF _amFeedToSeal THEN\n\t\t\t_amFeedToSeal := FALSE;\n\t\t\tstate := BAG_DELIVERY_STATES.FeedToSeal;\n\t\tEND_IF\n    \n\tBAG_DELIVERY_STATES.FeedToEye:\t\t\t\t\t\n\t\t\n\t\t// Feed to photoeye if not present\n\t\tIF iBagNotPresent THEN\n\t\t\tbagFeedMasterMotor.MoveDistance(\n\t\t\t\tdistance := feedToPhotoeyeSetpoint, \n                acceleration := accelSetpoint, \n                deceleration := decelSetpoint, \n                velocity := REAL_TO_INT((feedToPhotoeyeSetpoint * velocityMultiplier))\n\t\t\t);\n\t\t\tbagFeedRearMotor.MoveDistance(\n\t\t\t\tdistance := feedToPhotoeyeSetpoint, \n                acceleration := accelSetpoint, \n                deceleration := decelSetpoint, \n                velocity := REAL_TO_INT((feedToPhotoeyeSetpoint * velocityMultiplier))\n\t\t\t);\n\t\t\tIF bagFeedRearMotor.EIP THEN\n\t\t\t\tstate := BAG_DELIVERY_STATES.Sync;\n\t\t\t\t_nextState := BAG_DELIVERY_STATES.FeedingToEye;\n\t\t\tELSE\n\t\t\t\tstate := BAG_DELIVERY_STATES.FeedingToEye;\n\t\t\tEND_IF\n\t\tELSE\n\t\t\tstate := BAG_DELIVERY_STATES.SetTorqueMode;\n\t\tEND_IF\t\n\t\t\t\t\t\t\t\n\tBAG_DELIVERY_STATES.FeedingToEye:\n\t\t\t\t\n\t\t// Stop once photoeye seen\n\t\t_delayTimer.PT := T#3S;\n\t\t_delayTimer.IN := TRUE;\n\t\tIF NOT iBagNotPresent THEN\n\t\t\t_delayTimer.IN := FALSE;\n\t\t\tbagFeedMasterMotor.Stop();\n\t\t\tstate := BAG_DELIVERY_STATES.SetTorqueMode;\n\t\tEND_IF\n\t\tIF _delayTimer.Q THEN\n\t\t\tstate := BAG_DELIVERY_STATES.Fault;\n\t\t\tnoBagOverEye.Trigger();\n\t\t\t_delayTimer.IN := FALSE;\n\t\tEND_IF\n\t\n\tBAG_DELIVERY_STATES.SetTorqueMode:\n\t\n\t\t//\n\t\tIF NOT bagFeedRearMotor.EIP THEN\n\t\t\t// Set torque following mode\n\t\t\t_delayTimer.PT := T#50MS;\n\t\t\t_delayTimer.IN := TRUE;\n\t\t\tIF _delayTimer.Q THEN\n\t\t\t\t_delayTimer.IN := FALSE;\n\t\t\t\tbagFeedMasterMotor.TriggerTorqueMode();\n\t\t\t\tstate := BAG_DELIVERY_STATES.Idle;\t\n\t\t\tEND_IF\t\n\t\tELSE\n\t\t\tbagFeedRearMotor.TriggerTorqueMode();\n\t\t\tstate := BAG_DELIVERY_STATES.SetTorqueValue;\n\t\tEND_IF\n\t\t\n\tBAG_DELIVERY_STATES.SetTorqueValue:\n\t\t\n\t\t//\n\t\tIF bagFeedRearMotor.commandSuccessful THEN\n\t\t\tIF mailerMaterial = MAILER_MATERIAL.paper THEN\n\t\t\t\tbagFeedRearMotor.SetTorque(torque := paperTorqueSetting);\n\t\t\tELSE\n\t\t\t\tbagFeedRearMotor.SetTorque(torque := polyTorqueSetting);\n\t\t\tEND_IF\n\t\t\t\n\t\t\tstate := BAG_DELIVERY_STATES.Idle;\n\t\tEND_IF\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n    BAG_DELIVERY_STATES.Reverse:  \n                 \n\t\t// Reverse to break perf\n        bagFeedMasterMotor.MoveDistance(\n\t\t\tdistance := reverseDistanceSetpoint, \n            acceleration := TO_INT((ABS(reverseDistanceSetpoint) * Globals.STEPS_PER_INCH_20_DEGREE_BAG_DELIVERY) *  _accelPercent),\n            deceleration := TO_INT((ABS(reverseDistanceSetpoint) * Globals.STEPS_PER_INCH_20_DEGREE_BAG_DELIVERY) *  _decelPercent), \n            velocity := REAL_TO_INT((reverseVelocitySetpoint * velocityMultiplier))\n\t\t);\n\t\t  bagFeedRearMotor.MoveDistance(\n\t\t\tdistance := reverseDistanceSetpoint, \n            acceleration := TO_INT((ABS(reverseDistanceSetpoint) * Globals.STEPS_PER_INCH_20_DEGREE_BAG_DELIVERY) *  _accelPercent),\n            deceleration := TO_INT((ABS(reverseDistanceSetpoint) * Globals.STEPS_PER_INCH_20_DEGREE_BAG_DELIVERY) *  _decelPercent), \n            velocity := REAL_TO_INT((reverseVelocitySetpoint * velocityMultiplier))\n\t\t);    \n\t\tUpdateStateAfterSync(stt := BAG_DELIVERY_STATES.Reversing);\n                                       \n    BAG_DELIVERY_STATES.Reversing:\n\t\n\t\t// Back up until we see the trailing edge of the bag\n\t\tIF iBagNotPresent OR HMIData.enableDryCycle THEN\n\t\t\t_delayTimer.PT := T#10MS;\n\t\t\t_delayTimer.IN := TRUE;\n\t\t\tIF _delayTimer.Q THEN\n\t\t\t\t_delayTimer.IN := FALSE;\n\t\t\t\t_delayForReverseFault.IN := FALSE;\n\t\t\t\tbagFeedMasterMotor.Stop();\n\t\t\t\tIF _interconnect = BAG_DELIVERY_IC.EIP THEN\n\t\t\t\t\tbagFeedRearMotor.Stop();\n\t\t\t\tEND_IF\n\t\t\t\tIF reverseToPrintheadRequired THEN\n\t\t\t\t\tstate := BAG_DELIVERY_STATES.ReverseToPrinthead;\n\t\t\t\tELSE\n\t\t\t\t\tstate := BAG_DELIVERY_STATES.ReverseDone;\n\t\t\t\tEND_IF\n\t\t\tEND_IF\n\t\tELSIF NOT iBagNotPresent THEN\n\t\t\t_delayForReverseFault.PT := T#1S;\n\t\t\t_delayForReverseFault.IN := TRUE;\n\t\t\tIF _delayForReverseFault.Q THEN\n\t\t\t\treverseFault.Trigger();\n\t\t\t\tbagFeedMasterMotor.Stop();\n\t\t\t\tIF _interconnect = BAG_DELIVERY_IC.EIP THEN\n\t\t\t\t\tbagFeedRearMotor.Stop();\n\t\t\t\tEND_IF\n\t\t\t\t_delayForReverseFault.IN := FALSE;\n\t\t\t\tstate := BAG_DELIVERY_STATES.Fault; \n\t\t\tEND_IF\n\t\tEND_IF\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tBAG_DELIVERY_STATES.ReverseToPrinthead:\n                    \n\t\t// Reverse to print head\n        _delayTimer.PT := T#50MS;\n\t\t_delayTimer.IN := TRUE;\n\t\tIF _delayTimer.Q THEN\n\t\t\t_delayTimer.IN := FALSE;\n\t\t\tbagFeedMasterMotor.MoveDistanceFinal(\n\t\t\t\tdistance := _reverseToPrintHeadSetpoint, \n                acceleration := TO_INT((ABS(_reverseToPrintHeadSetpoint) * Globals.STEPS_PER_INCH_20_DEGREE_BAG_DELIVERY) *  _accelPercent),\n                deceleration := TO_INT((ABS(_reverseToPrintHeadSetpoint) * Globals.STEPS_PER_INCH_20_DEGREE_BAG_DELIVERY) *  _decelPercent), \n                velocity := REAL_TO_INT((reverseVelocitySetpoint * velocityMultiplier))\n\t\t\t);\n\t\t\tbagFeedRearMotor.MoveDistanceFinal(\n\t\t\t\tdistance := _reverseToPrintHeadSetpoint, \n                acceleration := TO_INT((ABS(_reverseToPrintHeadSetpoint) * Globals.STEPS_PER_INCH_20_DEGREE_BAG_DELIVERY) *  _accelPercent),\n                deceleration := TO_INT((ABS(_reverseToPrintHeadSetpoint) * Globals.STEPS_PER_INCH_20_DEGREE_BAG_DELIVERY) *  _decelPercent), \n                velocity := REAL_TO_INT((reverseVelocitySetpoint * velocityMultiplier))\n\t\t\t);\n\t\t\tUpdateStateAfterSync(stt := BAG_DELIVERY_STATES.ReversingToPrintHead);\n\t\tEND_IF\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t\t\t\t\n\tBAG_DELIVERY_STATES.ReversingToPrintHead:\n\t\n\t\t// Reverse to break perf\n        _delayTimer.PT :=  T#50MS;\n\t\t_delayTimer.IN := TRUE;\n\t\tIF _delayTimer.Q THEN\n\t\t\t_delayTimer.IN := FALSE;\n\t\t\tIF CommandAcknowledged AND InPosition THEN\n            \tstate := BAG_DELIVERY_STATES.ReverseDone;\n        \tEND_IF\n\t\tEND_IF\n                                                    \n    BAG_DELIVERY_STATES.ReverseDone:   \n             \n\t\t// We don't print in semi auto or manual mode.  In auto mode if the printer is selected then we move to those states\n        IF _mode = DEVICE_MODES.SemiAuto OR _mode = DEVICE_MODES.Manual OR (_mode  = DEVICE_MODES.Auto AND _autoFeedDelay.Q) THEN\n            IF CommandAcknowledged THEN\n\t\t\t\tstate := BAG_DELIVERY_STATES.FeedBagOut;\n            \tremainingLength := bagLengthSetpoint;\n            \t_amFeedBagOut := FALSE;\n\t\t\tEND_IF\n        ELSIF (_mode  = DEVICE_MODES.Auto AND _amWaitForPrinter) THEN\n            IF CommandAcknowledged THEN\n\t\t\t\t_amWaitForPrinter := FALSE; \n\t\t\t\tstate := BAG_DELIVERY_STATES.WaitingForPrinter;\n\t\t\t\tremainingLength := bagLengthSetpoint - (printLengthSetpoint + printOffsetSetpoint + _printerExtraFeedLength); \n\t\t\tEND_IF  \n        END_IF                                         \n                                                    \n    BAG_DELIVERY_STATES.WaitingForPrinter: \n           \n\t\t// \n        IF (_mode  = DEVICE_MODES.Auto AND _amPrinterReady) THEN\n\t\t\tIF printOffsetSetpoint <> 0 THEN\n\t\t\t\tstate := BAG_DELIVERY_STATES.FeedToPrintOffset;\n\t\t\tELSE\n\t\t\t\tstate := BAG_DELIVERY_STATES.FedToPrintOffset;\n\t\t\tEND_IF\n            _amPrinterReady := FALSE;\n        END_IF\n                                                        \n    BAG_DELIVERY_STATES.FeedToPrintOffset: \n           \n\t\t// \n        bagFeedMasterMotor.MoveDistance(\n\t\t\tdistance := printOffsetSetpoint, \n            acceleration := accelSetpoint, \n            deceleration := decelSetpoint, \n            velocity := REAL_TO_INT((feedVelocitySetpoint * velocityMultiplier))\n\t\t);\n\t\tbagFeedRearMotor.MoveDistance(\n\t\t\tdistance := printOffsetSetpoint, \n            acceleration := accelSetpoint, \n            deceleration := decelSetpoint, \n            velocity := REAL_TO_INT((feedVelocitySetpoint * velocityMultiplier))\n\t\t);\n\t\tUpdateStateAfterSync(stt := BAG_DELIVERY_STATES.FeedingToPrintOffset);\n                                                    \n    BAG_DELIVERY_STATES.FeedingToPrintOffset:       \n\t\t\n\t\t// \n\t\t_delayTimer.PT := _checkMotorStatusDelay;\n\t\t_delayTimer.IN := TRUE;\n\t\tIF _delayTimer.Q THEN\n\t\t\t_delayTimer.IN := FALSE;\n\t\t\tIF CommandAcknowledged AND InPosition THEN\n            \tstate := BAG_DELIVERY_STATES.FedToPrintOffset;\n        \tEND_IF\n\t\tEND_IF\n                                                                                 \n    BAG_DELIVERY_STATES.FedToPrintOffset:           \n\t\t\n\t\t// \n\tIF HMIData.printOutOfCycleEnable THEN\n\t\tIF (_mode  = DEVICE_MODES.Auto) THEN //AND _amStartPrint) THEN\n            state := BAG_DELIVERY_STATES.CreateSlack;\n        END_IF\n\tELSE\n        IF (_mode  = DEVICE_MODES.Auto AND _amStartPrint) THEN\n            state := BAG_DELIVERY_STATES.FeedAtPrintSpeed;\n            _amStartPrint := FALSE;\n        END_IF\n\tEND_IF\t\n\t\n\tBAG_DELIVERY_STATES.CreateSlack:\n       bagFeedMasterMotor.MoveDistance(\n\t\t\tdistance := 0, \n            acceleration := accelSetpoint, \n            deceleration := decelSetpoint, \n            velocity := REAL_TO_INT((feedVelocitySetpoint * velocityMultiplier))\n\t\t);\n\t\tbagFeedRearMotor.MoveDistance(\n\t\t\tdistance := 0.75,//0.0625, \n            acceleration := accelSetpoint, \n            deceleration := decelSetpoint, \n            velocity := REAL_TO_INT((feedVelocitySetpoint * velocityMultiplier))\n\t\t);\n\t\tUpdateStateAfterSync(stt := BAG_DELIVERY_STATES.CreatingSlack);\t\t\t\t\t\n\n\n\tBAG_DELIVERY_STATES.CreatingSlack:\n\t\t// Wait until move is done\n\t\t_delayTimer.PT := _checkMotorStatusDelay;\n\t\t_delayTimer.IN := TRUE;\n\t\tIF _delayTimer.Q THEN\n\t\t\tIF bagFeedRearMotor.InPosition AND CommandAcknowledged THEN\n\t\t\t\tstate := BAG_DELIVERY_STATES.CreatedSlack;\n\t\t\t\t_delayTimer.IN := FALSE;\n\t\t\tEND_IF\n\t\tEND_IF\n\n\tBAG_DELIVERY_STATES.CreatedSlack:\n\t\t//\n        IF (_mode  = DEVICE_MODES.Auto AND _amStartPrint) THEN\n            state := BAG_DELIVERY_STATES.FeedAtPrintSpeed;\n            _amStartPrint := FALSE;\n        END_IF    \n                                                    \n\tBAG_DELIVERY_STATES.FeedAtPrintSpeed:\n\t\t// \n\t\t_delayTimer.PT := _delayForPrintFeed;\n\t\t_delayTimer.IN := TRUE;\n\t\tIF _delayTimer.Q OR HMIData.printOutOfCycleEnable THEN\n\t\t\t_delayTimer.IN := FALSE;\n\t\t\tbagFeedMasterMotor.MoveDistance(\n\t\t\t\tdistance := printLengthSetpoint + _printerExtraFeedLength, \n                acceleration := accelSetpoint, \n                deceleration := decelSetpoint, \n                velocity := REAL_TO_INT((TO_REAL(printVelocitySetpoint) * velocityMultiplier))\n\t\t\t);\n\t\t\tbagFeedRearMotor.MoveDistance(\n\t\t\t\tdistance := (printLengthSetpoint + _printerExtraFeedLength) * 1, \n                acceleration := accelSetpoint, \n                deceleration := decelSetpoint, \n                velocity := REAL_TO_INT((TO_REAL(printVelocitySetpoint) * velocityMultiplier * 1))\n\t\t\t);      \n\t\t\tUpdateStateAfterSync(stt := BAG_DELIVERY_STATES.FeedingAtPrintSpeed);\n\t\tEND_IF\t\n                      \n    BAG_DELIVERY_STATES.FeedingAtPrintSpeed:\n\n\t\t// \n\t\t_delayTimer.PT := _checkMotorStatusDelay;\n\t\t_delayTimer.IN := TRUE;\n\t\tIF _delayTimer.Q THEN\n\t\t\t_delayTimer.IN := FALSE;\n\t\t\tIF CommandAcknowledged AND InPosition THEN\n            \tstate := BAG_DELIVERY_STATES.FedAtPrintSpeed;\n        \tEND_IF\n\t\tEND_IF\n                                                                                   \n    BAG_DELIVERY_STATES.FedAtPrintSpeed:            \n\t\t\n\t\t// \n        IF (_mode  = DEVICE_MODES.Auto AND _amPrinterDone) THEN\n            state := BAG_DELIVERY_STATES.FeedBagOut;\n            _amPrinterDone := FALSE;\n        END_IF\n                                                    \n    BAG_DELIVERY_STATES.FeedBagOut:\n\t\t                \n\t\t// Feed bag length out\n\t\tremainingLength := (remainingLength + _sealBarToPrintHeadLength) - sealOffsetSetpoint;\n\t\tIF NOT reverseToPrintheadRequired THEN\n\t\t\tremainingLength := remainingLength + _reverseToPrintHeadSetpoint;\n\t\tEND_IF\n\t\tbagFeedMasterMotor.MoveDistanceFinal(\n\t\t\tdistance := remainingLength, \n            acceleration := accelSetpoint, \n            deceleration := decelSetpoint, \n            velocity := REAL_TO_INT((feedVelocitySetpoint * velocityMultiplier))\n\t\t);\n\t\tbagFeedRearMotor.MoveDistanceFinal(\n\t\t\tdistance := remainingLength, \n            acceleration := accelSetpoint, \n            deceleration := decelSetpoint, \n            velocity := REAL_TO_INT((feedVelocitySetpoint * velocityMultiplier))\n\t\t);\n\t\tUpdateStateAfterSync(stt := BAG_DELIVERY_STATES.FeedingBagOut);\n    \n    BAG_DELIVERY_STATES.FeedingBagOut:   \n          \n\t\t// Wait until move is done\n\t\t_delayTimer.PT := _checkMotorStatusDelay;\n\t\t_delayTimer.IN := TRUE;\n\t\tIF _delayTimer.Q THEN\n\t\t\tIF bagFeedMasterMotor.InPosition AND CommandAcknowledged THEN\n            \tstate := BAG_DELIVERY_STATES.FedBagOut;\n        \tEND_IF\n\t\t\t_delayTimer.IN := FALSE;\n\t\tEND_IF\n                                                    \n    BAG_DELIVERY_STATES.FedBagOut:   \n               \n\t\t// Go to the next ready state\n        IF _mode = DEVICE_MODES.Manual THEN \n            state := BAG_DELIVERY_STATES.Manual;\n        ELSE\n            state := BAG_DELIVERY_STATES.Ready;\n        END_IF\n\t\tHMIData.driveRollerClean.SetCount(HMIData.driveRollerClean.count + TO_INT(bagLengthSetpoint));\n        Globals.bagDeliveryCycleCount := Globals.bagDeliveryCycleCount + 1;\n\t\t\n\tBAG_DELIVERY_STATES.FeedToSeal:\n\t\t\n\t\t//\n\t\tbagFeedMasterMotor.MoveDistanceFinal(\n\t\t\tdistance := feedToSealSetpoint, \n            acceleration := accelSetpoint, \n            deceleration := decelSetpoint, \n            velocity := REAL_TO_INT((feedVelocitySetpoint * velocityMultiplier))\n\t\t);\n\t\tbagFeedRearMotor.MoveDistanceFinal(\n\t\t\tdistance := feedToSealSetpoint, \n            acceleration := accelSetpoint, \n            deceleration := decelSetpoint, \n            velocity := REAL_TO_INT((feedVelocitySetpoint * velocityMultiplier))\n\t\t);\n\t\tUpdateStateAfterSync(stt := BAG_DELIVERY_STATES.FeedingToSeal);\n\t\t\n\tBAG_DELIVERY_STATES.FeedingToSeal:\n\t\t\n\t\t// Wait until move is done\n\t\t_delayTimer.PT := _checkMotorStatusDelay;\n\t\t_delayTimer.IN := TRUE;\n\t\tIF _delayTimer.Q THEN\n\t\t\tIF bagFeedMasterMotor.InPosition AND CommandAcknowledged THEN\n            \tstate := BAG_DELIVERY_STATES.FedToSeal;\n        \tEND_IF\n\t\t\t_delayTimer.IN := FALSE;\n\t\tEND_IF\n\t\t\n\t\t\n\tBAG_DELIVERY_STATES.FedToSeal:\n\t\t\n\t\t//\n\t\tstate := BAG_DELIVERY_STATES.Ready;\n\t\t\n\tBAG_DELIVERY_STATES.Sync:\n\t\n\t\t// \n\t\tIF bagFeedMasterMotor.ackRequest AND bagFeedRearMotor.ackRequest THEN\n\t\t\tbagFeedMasterMotor.ack := TRUE;\n\t\t\tbagFeedRearMotor.ack := TRUE;\n\t\t\tstate := _nextState;\n\t\tEND_IF\t\n    \n    BAG_DELIVERY_STATES.Ready:  \n\n\t\t//                    \n\t\tIF (_mode = DEVICE_MODES.Auto AND _amReverseBag) OR _mode = DEVICE_MODES.SemiAuto THEN \n            state := BAG_DELIVERY_STATES.Reverse;\n            ClearCommands();\n        END_IF \n\t\tIF _amFeedToEye THEN\n\t\t\t_amFeedToEye := FALSE;\t\t\t\n\t\t\tstate := BAG_DELIVERY_STATES.SetTorqueMode;\n\t\tEND_IF\n\t\tIF _amFeedToSeal THEN\n\t\t\t_amFeedToSeal := FALSE;\n\t\t\tstate := BAG_DELIVERY_STATES.FeedToSeal;\n\t\tEND_IF\n\t\tIF iBagNotPresent AND NOT HMIData.enableDryCycle THEN \n\t\t\tstate := BAG_DELIVERY_STATES.Idle;\n    \tEND_IF\n    BAG_DELIVERY_STATES.Fault:                        \n\t\tClearCommands();\n    \n    BAG_DELIVERY_STATES.Manual:                     \n\t\tIF _mode = DEVICE_MODES.Auto THEN\n\t\t\tstate := BAG_DELIVERY_STATES.Ready;\t\n\t\tEND_IF\n\t\t\n\t\t// Manually feed bags out\n        IF feedBagPB THEN\n            state := BAG_DELIVERY_STATES.Reverse;\n            feedBagPB := FALSE;\n        END_IF\n                                                        \nEND_CASE","LineInfoPersistence":"(string)2d395c9e-d11a-4d68-b0f7-2c8c82b4bd63_Impl_LineIds"}}}},"Interface":{"@Type":"a9ed5b7e","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)FUNCTION_BLOCK FB_BagDelivery EXTENDS FB_BaseComponent IMPLEMENTS IComponentStatus\nVAR_INPUT\n\tfeedToSealSetpoint : REAL := 0;\n    feedBagPB : BOOL;                // Manually Feed bag out\n\tjogForwardPB : BOOL;\n\tjogReversePB : BOOL;\n\treverseToPrintheadRequired : BOOL;\n    bagsToFeedSetpoint : INT;        // Bags to feed setpoint for testing\n    reverseDistanceSetpoint : REAL := -3;  // Distance to reverse\n    bagLengthSetpoint : REAL := 23.5;  // Bag length to feed\n    accelSetpoint : INT := 600;            // Acceleration Setpoint\n    decelSetpoint : INT := 2000;        // Deceleration Setpoint\n    reverseVelocitySetpoint : INT := 3;            // Reverse Velocity setoint (IPS)\n    feedVelocitySetpoint : INT := 55;            // Bag Feed Velocity setoint (IPS)\n    printVelocitySetpoint : UDINT := 6;            // Print speed (IPS)\n    sealOffsetSetpoint : REAL := 1.5;            // Seal Offset\n    printOffsetSetpoint : REAL := 3;            // Print Offset\n    printLengthSetpoint : REAL := 8;                    // Print length\n\tfeedToPhotoeyeSetpoint : REAL := 2.0;\n\tuseLastPrinterDelta : BOOL := TRUE;\n\ttensionFailONS : FB_ONS;\n\tbagFeedMasterMotorCommFailInput : BOOL;\n\tbagFeedRearMotorCommFailInput : BOOL;\n\tstepsPerInchSetting : INT;\n\tvelocityMultiplier : REAL;\n\trearMotorConfigVersion : CONFIG_VERSIONS;\n\tfrontMotorConfigVersion : CONFIG_VERSIONS;\n\tmailerMaterial : MAILER_MATERIAL := MAILER_MATERIAL.poly;\n\tpaperTorqueSetting : DINT := 50;\n\tpolyTorqueSetting : DINT := 60;\nEND_VAR\nVAR_OUTPUT\n    state : BAG_DELIVERY_STATES;    // Current state of bag delivery component\n\treverseFault : FB_Fault(name := 'Reverse Fault');\n\tnoBagOverEye : FB_Fault(name := 'No bag over Photoeye');\n\tbagTensionFault : FB_Fault(name := 'Bag Tension Fault');\n\tremainingLength : REAL;            // Remaining bag length after print\nEND_VAR\nVAR\n\t _nextState : BAG_DELIVERY_STATES;\n    _delayTimer : TON := (PT := T#100MS);    // Delay for testing\n\t_jogForwardONS: Standard.R_TRIG;\n\t_jogReverseONS: Standard.R_TRIG;\n\t_delayForReverseFault : Standard.TON;\n\t_autoFeedDelay : TON := (PT := T#200MS);\n\t_sealBarToPrintHeadLength : REAL;\n\t_delayForPrintFeed : TIME := T#20MS;\n\t_printerExtraFeedLength : REAL := 0.25;\n\tbagFeedMasterMotor : FB_AppliedMotionBagDeliveryMotor();\n\tbagFeedRearMotor : FB_AppliedMotionBagDeliveryMotor();\n\t_accelPercent : REAL := 0.1;\n\t_decelPercent : REAL := 0.05;\n\t_amFeedToSeal : BOOL;            // Auto Mode - Feed Bag To 'FeedToSeal' Setting\n    _amReverseBag : BOOL;            // Auto Mode - Reverse bag\n    _amFeedBagOut : BOOL;            // Auto Mode - Feed new bag out\n    _amWaitForPrinter : BOOL;        // Auto Mode - wait for printer\n    _amPrinterReady : BOOL;            // Auto Mode - Printer is ready\n    _amStartPrint : BOOL;            // Auto Mode - Start Printing\n    _amPrinterDone : BOOL;             // Auto Mode - Printer is Done\n\t_amFeedToEye : BOOL;\t\t\t  // Auto Mode - Feed Bag to Eye\n\t_reverseSpeedDistanceOffset : REAL;\n\t_reverseToPrintHeadSetpoint : REAL;\n\t_checkMotorStatusDelay : TIME := T#25MS;\n\t_tensionFault : BOOL;\n\t_interconnect : BAG_DELIVERY_IC;\n\t_jogging : BOOL;\n\t_joggingDebounceTimer : Standard.TOF := (PT := T#250MS);\n\t_joggingONS : Standard.F_TRIG;\n\t_syncingONS : Standard.F_TRIG; \n\t_testTorqueNow : BOOL;\n\t_testTorqueValue : DINT;\n\nEND_VAR\n","LineInfoPersistence":"(string)2d395c9e-d11a-4d68-b0f7-2c8c82b4bd63_Decl_LineIds"}}}},"UniqueIdGenerator":"(string)24540","POULevel":{"@Type":"8e575c5b:Enum","@Value":"Standard"},"ChildObjectGuids":{"@Type":"ArrayList:IList","@Value":[]},"AddAttributeSubsequent":"(bool)False"}},"TypeInfos":{"0db3d7bb":"{0db3d7bb-cde0-4416-9a7b-ce49a0124323}","3b83b776":"{3b83b776-fb25-43b8-99f2-3c507c9143fc}","6f9dac99":"{6f9dac99-8de1-4efc-8465-68ac443b7d08}","8e575c5b":"{8e575c5b-1d37-49c6-941b-5c0ec7874787}","a9ed5b7e":"{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}","ArrayList":"System.Collections.ArrayList","bool":"System.Boolean","f3878285":"{f3878285-8e4f-490b-bb1b-9acbb7eb04db}","string":"System.String"}}},"FormatVersion":"1.0"}