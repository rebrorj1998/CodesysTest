{"payload":{"meta":{"Graph":{"@Type":"81297157","@Value":{"Guid":"(Guid)d98934da-6649-49ff-802f-050dd1b94773","ParentGuid":"(Guid)9266ed0f-7f1e-4370-8ffa-55b419b1a46d","Name":"(string)FB_ClampingMechanism","Properties":{"@Type":"2c41fa04:IDictionary","@Value":[{"@Key":"(Guid)829a18f2-c514-4f6e-9634-1df173429203","@Value":{"@Type":"829a18f2","@Value":{"ParentObjects":{"@Type":"fa2ee218:IDictionary","@Value":[{"@Key":"(Guid)d9b2b2cc-ea99-4c3b-aa42-1e5c49e65b84","@Value":"(Guid)1c5d99fe-a75b-4bab-bed7-3c1f495ffdb5"}]}}}}]},"TypeGuid":"(Guid)6f9dac99-8de1-4efc-8465-68ac443b7d08","EmbeddedTypeGuids":{"@Type":"[Guid]","@Value":["(Guid)a9ed5b7e-75c5-4651-af16-d2c27e98cb94","(Guid)3b83b776-fb25-43b8-99f2-3c507c9143fc"]}}},"TypeInfos":{"2c41fa04":"{2c41fa04-1834-41c1-816e-303c7aa2c05b}","81297157":"{81297157-7ec9-45ce-845e-84cab2b88ade}","829a18f2":"{829a18f2-c514-4f6e-9634-1df173429203}","fa2ee218":"{fa2ee218-a39b-4b6d-b249-49dbddbd168a}","Guid":"System.Guid","string":"System.String"}},"object":{"Graph":{"@Type":"6f9dac99","@Value":{"SpecialFunc":{"@Type":"0db3d7bb:Enum","@Value":"None"},"Implementation":{"@Type":"3b83b776","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)//\tFunction Block: FB_ClampingMechanism()\n//\tDescription: The 1195 clamping mechanism, which uses a brushless motor and gearbox to provide clamping force on the pressure bar.\t\t \n//\tCreated by: Ben Hess\n//\tCreated Date: 4/11/2023\nSUPER^();\n_jogOpenONS(CLK := jogOpenCMD);\n_jogClosedONS(CLK := jogClosedCMD);\n_maximumJogTimeTimer(IN:= jogOpenCMD OR jogClosedCMD);\nclampingMechanismDriveFault.faultTrigger := driveAlarm;\n_timeFromHomeToClampTimer(PT := timeFromHomeToClamp, IN := state = eClampingMechanismStates.ClampMovingToClamp);\n_maximumClampingTimeTimer(PT := maximumClampingTime, IN := state = eClampingMechanismStates.ClampMovedToClamp);\n_maximumReverseTimeTimer(PT := maximumReverseTime, IN := oStartMotor = TRUE AND oForwardMotor = FALSE);//;state = eClampingMechanismStates.ClampMovingToRelease);\n_resetDriveOutputPulse.DwellSetting := DRIVE_RESET_PULSE_TIME_IN_MS;\n_resetDriveOutputPulse(Q => oResetDrive,_reset := _reset);\n_clamping := state = eClampingMechanismStates.ClampMovedToClamp;\n_moving :=  state = eClampingMechanismStates.ClampMovingToClamp\n\t\t\tOR state = eClampingMechanismStates.ClampMovingToRelease;\n_cleared := homeSensor ;//OR homeSensorNotSeen;\n//code to add timer to track duration in states\n_IsHomed := homeSensor OR _maximumReverseTimeTimer.q;\nstateTimer(PT:=T#10000S);\n_activeFault := clampingMechanismDriveFault.Active;\n_faultONS(CLK := _activeFault AND NOT oResetDrive );\nIF _faultONS.OSR THEN \n\tstate:= eClampingMechanismStates.Fault;\nEND_IF\nIF clr THEN\n\tspeedTracking:=speedTracking_mt;\n\tclr:=FALSE;\nEND_IF\nIF state  = laststate THEN\n\tstateTimer.IN := TRUE;\nELSIF state  <> laststate THEN\n\tstateTimer.IN := FALSE;\n\tIF state =0 THEN\n\t\tcount_index := count_index +1;\n\tEND_IF\n\tlaststate:=state;\nEND_IF\nspeedTracking[state_index][count_index] := stateTimer.ET;\n\nIF count_index >=20 THEN\n\tcount_index :=0;\nEND_IF\n\n//End modded code\n_stateString := TO_STRING(state);\n_ready := state = eClampingMechanismStates.Idle AND  NOT driveAlarm AND _cleared;\nCASE state OF\n\teClampingMechanismStates.Idle:  \n\t\tIF jogClosedCMD AND NOT _maximumJogTimeTimer.Q THEN\n\t\t\toStartMotor := TRUE;\n\t\t\toForwardMotor := TRUE;\n\t\t\tmanMoving := TRUE;\n\t\tEND_IF\n\t\tIF jogOpenCMD AND NOT _maximumJogTimeTimer.Q THEN\n\t\t\toStartMotor := TRUE;\n\t\t\toForwardMotor := FALSE;\n\t\t\tmanMoving := TRUE;\n\t\tEND_IF\n\t\tIF  _maximumJogTimeTimer.Q OR (NOT jogClosedCMD AND NOT jogOpenCMD)  THEN\n\t\t\tmanMoving := FALSE;\n\t\t\toStartMotor := FALSE;\n\t\t\toForwardMotor := TRUE;\n\t\tEND_IF\n\t\tstate_index := 0;\n\t\t// Idle. Wait for command\n\t\tIF NOT manMoving THEN\n\t\t\toStartMotor := FALSE;\n\t\t\toForwardMotor := TRUE;\n\t\tEND_IF\n\t\thomeSensorNotSeen := FALSE;\n\t\tIF _homeNow OR _makeReady THEN\n\t\t\tstate := eClampingMechanismStates.Home;\n\t\t\t_homeNow := FALSE;\n\t\t\t_makeReady := FALSE;\n\t\tEND_IF\n\t\tIF _startClamping AND NOT driveAlarm THEN\n\t\t\t_startClamping := FALSE;\n\t\t\t//homeSensorNotSeen := FALSE;\n\t\t\tstate := eClampingMechanismStates.ClampMoveToClamp;\n\t\tEND_IF\n\t\tIF _stopClamping AND NOT homeSensor THEN\n\t\t\tstate := eClampingMechanismStates.ClampMoveToRelease;\n\t\tELSE\n\t\t\t_stopClamping:= FALSE;\n\t\tEND_IF\n\teClampingMechanismStates.Home:  \n\t\t\n\t\tIF homeSensor OR _maximumReverseTimeTimer.Q THEN\n\t\t\t\n\t\t\tstate := eClampingMechanismStates.Idle;\n\t\tELSE\n\t\t\tstate:=eClampingMechanismStates.Homing;\n\t\tEND_IF\n\teClampingMechanismStates.Homing:  \n\t\tIF NOT (homeSensor OR _maximumReverseTimeTimer.Q) THEN\n\t\t\toForwardMotor := FALSE;\t\n\t\t\toStartMotor:= TRUE;\n\t\tELSE\n\t\t\toForwardMotor := TRUE;\t\n\t\t\toStartMotor:= FALSE;\t\n\t\t\tstate:=eClampingMechanismStates.Idle;\t\t\t\n\t\tEND_IF\n\t\n\teClampingMechanismStates.ClampMoveToClamp:\n\t\tstate_index := 4;\n\t\t// Start moving to clamp\n\t\toStartMotor := TRUE;\n\t\toForwardMotor := TRUE;\n\t\t_moving := TRUE;\n\t\tstate := eClampingMechanismStates.ClampMovingToClamp;\n\t\t\n\teClampingMechanismStates.ClampMovingToClamp:\t\n\t\tstate_index := 1;\n\t\t// Wait for timer to move to clamp positon \n\t\tIF _timeFromHomeToClampTimer.Q OR _stopClamping THEN\n\t\t\tstate := eClampingMechanismStates.ClampMovedToClamp;\n\t\tEND_IF\n\t\n\teClampingMechanismStates.ClampMovedToClamp:\n\t\tstate_index := 2;\n\t\t// Wait for command to reverse, or maximum timeout reached\n\t\tIF _stopClamping OR _maximumClampingTimeTimer.Q THEN\n\t\t\t_stopClamping := FALSE;\n\t\t\t// Flag on max clamping time exceeded\n\t\t\tmaximumClampingTimeExceeded := _maximumClampingTimeTimer.Q;\n\t\t\t_closingTime := _maximumClampingTimeTimer.ET;\n\t\t\t_closingTimeArray[_closingTimeCycles] := _closingTime;\n\t\t\t\n\t\t\tIF _closingTimeCycles > 1 THEN\n\t\t\t\t_closingTimeAverage := (((_closingTimeAverage*(_closingTimeCycles-1)) + _closingTime)/(_closingTimeCycles));\n\t\t\tELSE \n\t\t\t\t_closingTimeAverage := _closingTime;\n\t\t\tEND_IF\n\t\t\t_closingTimeCycles := _closingTimeCycles +1;\n\t\t\tstate := eClampingMechanismStates.ClampMoveToRelease;\n\t\tEND_IF\n\t\t\n\t\t \n\t\n\teClampingMechanismStates.ClampMoveToRelease:\n\t\tstate_index := 5;\n\t\t// Start moving to release \n\t\toStartMotor := TRUE;\n\t\toForwardMotor := FALSE;\n\t\tstate := eClampingMechanismStates.ClampMovingToRelease;\t\t\n\t\teClampingMechanismStates.ClampMovingToRelease:\t\n\t\tstate_index := 3;\n\t\t// Wait for home sensor, or maximum reverse time\n\t\tIF homeSensor OR _maximumReverseTimeTimer.Q THEN\n\t\t\t_stopClamping := FALSE;\n\t\t\t// Flag on broken sensor\n\t\t\thomeSensorNotSeen := _maximumReverseTimeTimer.Q;\n\t\t\t\n\t\t\t_releasingTime := _maximumReverseTimeTimer.ET;\n\t\t\t_releasingTimeArray[_releasingTimeCycles] := _releasingTime;\n\t\t\t\n\t\t\tIF _releasingTimeCycles > 1 THEN\n\t\t\t\t_releasingTimeAverage := (((_releasingTimeAverage*(_releasingTimeCycles-1)) + _releasingTime)/(_releasingTimeCycles));\n\t\t\tELSE \n\t\t\t\t_releasingTimeAverage := _releasingTime;\n\t\t\tEND_IF\n\t\t\t_releasingTimeCycles := _releasingTimeCycles +1;\n\t\t\tstate := eClampingMechanismStates.ClampMovedToRelease;\t\t\t\t\n\t\tEND_IF\n\t\t\n\teClampingMechanismStates.ClampMovedToRelease:\n\t\tstate_index := 6;\n\t\t// Home. \n\t\t_releasingTime := _maximumReverseTimeTimer.ET;\n\t\tstate := eClampingMechanismStates.Idle;\n\t\n\teClampingMechanismStates.Fault:\n\t\tstate_index := 7;\n\t\toStartMotor := FALSE;\n\t\toForwardMotor := FALSE;\n\t\tstate := eClampingMechanismStates.Faulting;\n\teClampingMechanismStates.Faulting:\n\t\tstate_index := 8;\n\t\tstate := eClampingMechanismStates.Faulted;\n\t\n\teClampingMechanismStates.Faulted:\n\t\tstate_index := 9;\n\t\n\teClampingMechanismStates.Reset:\n\t\tstate_index := 10;\n\t\t// Start reset process\n\t\toStartMotor := FALSE;\n\t\toForwardMotor := FALSE;\n\t\t_resetDriveOutputPulse.Trigger();\n\t\tstate := eClampingMechanismStates.Resetting;\n\t\t\n\teClampingMechanismStates.Resetting:\n\t\tstate_index := 11;\n\t\t// Wait for alarm to go away\n\t\tIF _resetDriveOutputPulse.Q THEN\n\t\t\t\tstate := eClampingMechanismStates.ResetDone;\n\t\tEND_IF\n\t\t\n\teClampingMechanismStates.ResetDone:\n\t\tstate_index := 12;\n\t\t// Go back to idle\n\t\tstate := eClampingMechanismStates.Idle;\nEND_CASE\n\n\nIF _closingTime > _closingTimeHighest AND _closingTime < maximumClampingTime THEN\n\t_closingTimeHighest := _closingTime;\nEND_IF\n\nIF _closingTime < _closingTimeLowest AND _closingTime > T#0s THEN\n\t_closingTimeLowest := _closingTime;\nEND_IF\n\nIF _releasingTime > _releasingTimeHighest AND _releasingTime < maximumReverseTime THEN\t\n\t_releasingTimeHighest := _releasingTime;\nEND_IF\n\nIF _releasingTime < _releasingTimeLowest AND _releasingTime > T#0S THEN\n\t_releasingTimeLowest := _releasingTime;\nEND_IF\n","LineInfoPersistence":"(string)d98934da-6649-49ff-802f-050dd1b94773_Impl_LineIds"}}}},"Interface":{"@Type":"a9ed5b7e","@Value":{"TextDocument":{"@Type":"f3878285","@Value":{"TextBlobForSerialisation":"(string)FUNCTION_BLOCK FB_ClampingMechanism EXTENDS FB_BaseComponent IMPLEMENTS IClampingMechanism, IHomable\nVAR_INPUT\n\tdriveAlarm : BOOL;\n\thomeSensor : BOOL;\n\ttimeFromHomeToClamp : TIME := T#500MS; // Time between starting the clamp motion to when we call it clamped.\n\tmaximumClampingTime : TIME := T#4.8S;  // Maximum possible clamping time before drive will fault.\n\tmaximumReverseTime : TIME := T#540MS;\n\tjogOpenCMD : BOOL := FALSE;\n\tjogClosedCMD: BOOL := FALSE;\nEND_VAR\nVAR_OUTPUT\n\toStartMotor : BOOL;\n\toForwardMotor : BOOL;\n\toResetDrive : BOOL;\n\tmaximumClampingTimeExceeded : BOOL;\n\thomeSensorNotSeen : BOOL;\n\treversing : BOOL;\n\tstate : eClampingMechanismStates;\t\nEND_VAR\nVAR\n\t_homeNow: BOOL;\n\t_IsHomed: BOOL;\n\t_releaseDelay : TIME := T#150MS;\n\t_startClamping : BOOL;\n\t_stopClamping : BOOL;\n\t_moving : BOOL;\n\t_cleared : BOOL;\n\t_clamping : BOOL;\n\t_resetDriveOutputPulse : FB_MonostableMultivibrator;\n\t//Timers\n\t_timeFromHomeToClampTimer : TON;\n\t_maximumClampingTimeTimer : TON;\n\t_maximumReverseTimeTimer : TON;\n\t_maximumJogTimeTimer : TON := (PT:= T#1500MS);\n\t\n\t_closingTime : TIME;\n\t_closingTimeHighest : TIME;\n\t_closingTimeLowest : TIME := T#10S;\n\t_releasingTime : TIME;\n\t_releasingTimeHighest : TIME;\n\t_releasingTimeLowest : TIME := T#10S;\n\t_closingTimeArray : ARRAY[0..1000] OF TIME;\n\t_closingTimeaverage : TIME;\n\t_closingTimeCycles : INT :=0;\n\t_releasingTimeArray : ARRAY[0..1000] OF TIME;\n\t_releasingTimeAverage : TIME;\n\t_releasingTimeWorkingVar : TIME;\n\t_releasingTimeCycles : INT :=0;\n\t\n\t\t\t//variables for the state timer\n\tstateTimer:TON;\n\tlaststate: INT;\n\tcount_index :INT :=0;\n\tclr:BOOL:=FALSE;\n\tspeedTracking : ARRAY[0..20] OF ARRAY[0..20] OF TIME;\n\tspeedTracking_mt : ARRAY[0..20] OF ARRAY[0..20] OF TIME:=[21([21(T#0S)])]; \n\tstate_index : INT:=0;\n\tclampingMechanismDriveFault : FB_Fault(name := CONCAT(_prefix, 'Drive Fault'),  faultID := faultMessageList.CLAMP_DRIVE_FAULT);\n\t_faultONS: FB_ONS;\n\t_activeFault: BOOL;\n\t_jogOpenONS: FB_ONS;\n\t_jogClosedONS: FB_ONS;\n\tmanMoving: BOOL := FALSE;\nEND_VAR\nVAR_IN_OUT\n\nEND_VAR\nVAR CONSTANT\n\tDRIVE_RESET_PULSE_TIME_IN_MS : UINT := 500;\nEND_VAR","LineInfoPersistence":"(string)d98934da-6649-49ff-802f-050dd1b94773_Decl_LineIds"}}}},"UniqueIdGenerator":"(string)770","POULevel":{"@Type":"8e575c5b:Enum","@Value":"Standard"},"ChildObjectGuids":{"@Type":"ArrayList:IList","@Value":[]},"AddAttributeSubsequent":"(bool)False"}},"TypeInfos":{"0db3d7bb":"{0db3d7bb-cde0-4416-9a7b-ce49a0124323}","3b83b776":"{3b83b776-fb25-43b8-99f2-3c507c9143fc}","6f9dac99":"{6f9dac99-8de1-4efc-8465-68ac443b7d08}","8e575c5b":"{8e575c5b-1d37-49c6-941b-5c0ec7874787}","a9ed5b7e":"{a9ed5b7e-75c5-4651-af16-d2c27e98cb94}","ArrayList":"System.Collections.ArrayList","bool":"System.Boolean","f3878285":"{f3878285-8e4f-490b-bb1b-9acbb7eb04db}","string":"System.String"}}},"FormatVersion":"1.0"}