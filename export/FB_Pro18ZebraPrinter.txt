

FUNCTION_BLOCK FINAL FB_Pro18ZebraPrinter EXTENDS FB_BasicPrinter
VAR_INPUT
	printHead : IUpDown;
	printHeadDebounceSetpoint : TIME;
END_VAR
VAR_OUTPUT
	serviceRequired : FB_Fault(name := Standard.CONCAT(_prefix,'Service Required'));
	ribbonLow : Warning;
END_VAR
VAR
	printHeadDebounceTimer : Standard.TON;
	printerPrintingONS : FB_ONS;
	printDoneSim : FB_MonostableMultivibrator(name := 'Print Done Sim=');
END_VAR
VAR_IN_OUT
	dataReadyInput : FB_PhysicalDigitalInput;
	serviceRequiredInput : FB_PhysicalDigitalInput;
	ribbonLowInput : FB_PhysicalDigitalInput;
	endOfPrintInput : FB_PhysicalDigitalInput;
	startPrintOutput : FB_PhysicalDigitalOutput;
	ribbonUnwindRunOutput : FB_PhysicalDigitalOutput;
END_VAR

//	Function Block: FB_Pro18ZebraPrinter()
//	Description: Pro-18 Zebra Printer
//				 Printer applicator should be in Mode 2, in which the End Of Print input stays high while printing,
//				 this way we can release the print head and not waste ribbon if the label is shorter than
//	Created by: Ben Hess
//	Created Date: Thursday, August 1st, 2019

SUPER^();

// Setup of inputs and faults, warnings
_hasLabel := dataReadyInput.Active OR simulateIO;

IF serviceRequiredInput.Active AND THIS^.OptionEnabled THEN
	serviceRequired.Trigger();
END_IF

ribbonLow.active := ribbonLowInput.Active AND THIS^.OptionEnabled;

// Simulation setup
EnableSimulation(printHead, simulateIO);
EnableSimulation(startPrintOutput, simulateIO);
EnableSimulation(ribbonUnwindRunOutput, simulateIO);
endOfPrintInput.simulate := simulateIO;
endOfPrintInput.simValue := printDoneSim.Q;

printDoneSim.DwellSetting := TO_UINT(((printLength / TO_REAL(printSpeed)) * 1000) + 50.0);
printDoneSim();


printHeadDebounceTimer(PT := printHeadDebounceSetpoint);
printerPrintingONS(CLK := endOfPrintInput.Active);

IF _reset THEN
	state := 100;
	_reset := FALSE;
END_IF

CASE state OF
	0:		// Idle
			IF _beginPrinting AND THIS^.OptionEnabled THEN
				state := 10;
				_printDone := FALSE;
				_beginPrinting := FALSE;
			END_IF
	
	10:		// Start Print cycle
			printHead.MoveDown();
			printHeadDebounceTimer.IN := TRUE;
			_logger.AddLogItem(CONCAT(_prefix, 'Print Started'));
			state := 11;
	
	11:		//Wait for print head debounce
			IF printHeadDebounceTimer.Q THEN
				printHeadDebounceTimer.IN := FALSE;
				startPrintOutput.TurnOn();
				ribbonUnwindRunOutput.TurnOn();
				printDoneSim.Trigger();
				state := 12;
				_printing := TRUE;
			END_IF
	
	12:		// Print until finished or faulted
			IF printerPrintingONS.OSF OR serviceRequired.FaultActive THEN
				startPrintOutput.TurnOff();
				ribbonUnwindRunOutput.TurnOff();
				printHead.MoveUp();
				_printing := FALSE;
				_printDone := TRUE;
				_logger.AddLogItem(CONCAT(_prefix, 'Print Done'));
				state := 0;
			END_IF

		
	100:	// Clear status
			_printing := FALSE;
			_beginPrinting := FALSE;
			_printDone := FALSE;
			printDoneSim.ManualOff();
			startPrintOutput.TurnOff();
			ribbonUnwindRunOutput.TurnOff();
			printHeadDebounceTimer.IN := FALSE;
			state := 0;
END_CASE

FUNCTION_BLOCK FINAL FB_Pro18ZebraPrinter EXTENDS FB_BasicPrinter
VAR_INPUT
	printHead : IUpDown;
	printHeadDebounceSetpoint : TIME;
END_VAR
VAR_OUTPUT
	serviceRequired : FB_Fault(name := Standard.CONCAT(_prefix,'Service Required'));
	ribbonLow : Warning;
END_VAR
VAR
	printHeadDebounceTimer : Standard.TON;
	printerPrintingONS : FB_ONS;
	printDoneSim : FB_MonostableMultivibrator(name := 'Print Done Sim=');
END_VAR
VAR_IN_OUT
	dataReadyInput : FB_PhysicalDigitalInput;
	serviceRequiredInput : FB_PhysicalDigitalInput;
	ribbonLowInput : FB_PhysicalDigitalInput;
	endOfPrintInput : FB_PhysicalDigitalInput;
	startPrintOutput : FB_PhysicalDigitalOutput;
	ribbonUnwindRunOutput : FB_PhysicalDigitalOutput;
END_VAR

//	Function Block: FB_Pro18ZebraPrinter()
//	Description: Pro-18 Zebra Printer
//				 Printer applicator should be in Mode 2, in which the End Of Print input stays high while printing,
//				 this way we can release the print head and not waste ribbon if the label is shorter than
//	Created by: Ben Hess
//	Created Date: Thursday, August 1st, 2019

SUPER^();

// Setup of inputs and faults, warnings
_hasLabel := dataReadyInput.Active OR simulateIO;

IF serviceRequiredInput.Active AND THIS^.OptionEnabled THEN
	serviceRequired.Trigger();
END_IF

ribbonLow.active := ribbonLowInput.Active AND THIS^.OptionEnabled;

// Simulation setup
EnableSimulation(printHead, simulateIO);
EnableSimulation(startPrintOutput, simulateIO);
EnableSimulation(ribbonUnwindRunOutput, simulateIO);
endOfPrintInput.simulate := simulateIO;
endOfPrintInput.simValue := printDoneSim.Q;

printDoneSim.DwellSetting := TO_UINT(((printLength / TO_REAL(printSpeed)) * 1000) + 50.0);
printDoneSim();


printHeadDebounceTimer(PT := printHeadDebounceSetpoint);
printerPrintingONS(CLK := endOfPrintInput.Active);

IF _reset THEN
	state := 100;
	_reset := FALSE;
END_IF

CASE state OF
	0:		// Idle
			IF _beginPrinting AND THIS^.OptionEnabled THEN
				state := 10;
				_printDone := FALSE;
				_beginPrinting := FALSE;
			END_IF
	
	10:		// Start Print cycle
			printHead.MoveDown();
			printHeadDebounceTimer.IN := TRUE;
			_logger.AddLogItem(CONCAT(_prefix, 'Print Started'));
			state := 11;
	
	11:		//Wait for print head debounce
			IF printHeadDebounceTimer.Q THEN
				printHeadDebounceTimer.IN := FALSE;
				startPrintOutput.TurnOn();
				ribbonUnwindRunOutput.TurnOn();
				printDoneSim.Trigger();
				state := 12;
				_printing := TRUE;
			END_IF
	
	12:		// Print until finished or faulted
			IF printerPrintingONS.OSF OR serviceRequired.FaultActive THEN
				startPrintOutput.TurnOff();
				ribbonUnwindRunOutput.TurnOff();
				printHead.MoveUp();
				_printing := FALSE;
				_printDone := TRUE;
				_logger.AddLogItem(CONCAT(_prefix, 'Print Done'));
				state := 0;
			END_IF

		
	100:	// Clear status
			_printing := FALSE;
			_beginPrinting := FALSE;
			_printDone := FALSE;
			printDoneSim.ManualOff();
			startPrintOutput.TurnOff();
			ribbonUnwindRunOutput.TurnOff();
			printHeadDebounceTimer.IN := FALSE;
			state := 0;
END_CASE

FUNCTION_BLOCK FINAL FB_Pro18ZebraPrinter EXTENDS FB_BasicPrinter
VAR_INPUT
	printHead : IUpDown;
	printHeadDebounceSetpoint : TIME;
END_VAR
VAR_OUTPUT
	serviceRequired : FB_Fault(name := Standard.CONCAT(_prefix,'Service Required'));
	ribbonLow : Warning;
END_VAR
VAR
	printHeadDebounceTimer : Standard.TON;
	printerPrintingONS : FB_ONS;
	printDoneSim : FB_MonostableMultivibrator(name := 'Print Done Sim=');
END_VAR
VAR_IN_OUT
	dataReadyInput : FB_PhysicalDigitalInput;
	serviceRequiredInput : FB_PhysicalDigitalInput;
	ribbonLowInput : FB_PhysicalDigitalInput;
	endOfPrintInput : FB_PhysicalDigitalInput;
	startPrintOutput : FB_PhysicalDigitalOutput;
	ribbonUnwindRunOutput : FB_PhysicalDigitalOutput;
END_VAR

//	Function Block: FB_Pro18ZebraPrinter()
//	Description: Pro-18 Zebra Printer
//				 Printer applicator should be in Mode 2, in which the End Of Print input stays high while printing,
//				 this way we can release the print head and not waste ribbon if the label is shorter than
//	Created by: Ben Hess
//	Created Date: Thursday, August 1st, 2019

SUPER^();

// Setup of inputs and faults, warnings
_hasLabel := dataReadyInput.Active OR simulateIO;

IF serviceRequiredInput.Active AND THIS^.OptionEnabled THEN
	serviceRequired.Trigger();
END_IF

ribbonLow.active := ribbonLowInput.Active AND THIS^.OptionEnabled;

// Simulation setup
EnableSimulation(printHead, simulateIO);
EnableSimulation(startPrintOutput, simulateIO);
EnableSimulation(ribbonUnwindRunOutput, simulateIO);
endOfPrintInput.simulate := simulateIO;
endOfPrintInput.simValue := printDoneSim.Q;

printDoneSim.DwellSetting := TO_UINT(((printLength / TO_REAL(printSpeed)) * 1000) + 50.0);
printDoneSim();


printHeadDebounceTimer(PT := printHeadDebounceSetpoint);
printerPrintingONS(CLK := endOfPrintInput.Active);

IF _reset THEN
	state := 100;
	_reset := FALSE;
END_IF

CASE state OF
	0:		// Idle
			IF _beginPrinting AND THIS^.OptionEnabled THEN
				state := 10;
				_printDone := FALSE;
				_beginPrinting := FALSE;
			END_IF
	
	10:		// Start Print cycle
			printHead.MoveDown();
			printHeadDebounceTimer.IN := TRUE;
			_logger.AddLogItem(CONCAT(_prefix, 'Print Started'));
			state := 11;
	
	11:		//Wait for print head debounce
			IF printHeadDebounceTimer.Q THEN
				printHeadDebounceTimer.IN := FALSE;
				startPrintOutput.TurnOn();
				ribbonUnwindRunOutput.TurnOn();
				printDoneSim.Trigger();
				state := 12;
				_printing := TRUE;
			END_IF
	
	12:		// Print until finished or faulted
			IF printerPrintingONS.OSF OR serviceRequired.FaultActive THEN
				startPrintOutput.TurnOff();
				ribbonUnwindRunOutput.TurnOff();
				printHead.MoveUp();
				_printing := FALSE;
				_printDone := TRUE;
				_logger.AddLogItem(CONCAT(_prefix, 'Print Done'));
				state := 0;
			END_IF

		
	100:	// Clear status
			_printing := FALSE;
			_beginPrinting := FALSE;
			_printDone := FALSE;
			printDoneSim.ManualOff();
			startPrintOutput.TurnOff();
			ribbonUnwindRunOutput.TurnOff();
			printHeadDebounceTimer.IN := FALSE;
			state := 0;
END_CASE