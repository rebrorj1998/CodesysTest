

FUNCTION_BLOCK FB_CollectionHandlerActiveFaults
VAR_INPUT
END_VAR
VAR
	Collection: ARRAY[0..GlobalObjects.MAX_FAULTS] OF IFault; // object array
	ObjNames   : ARRAY[0..GlobalObjects.MAX_FAULTS] OF STRING;
	_ArrayOver   : BOOL;
	_BadObj      : INT;
	_DupeObj   : INT;
	_OverObj   : INT;
	_TotalObj   : UINT;
END_VAR

VAR_OUTPUT
	faultActive : BOOL;
END_VAR
//	Function Block: FB_CollectionHandlerActiveFaults
//	Description: This collection handler adds and removes active faults to an array
//				 The add and remove methods are called from FB_Fault
//	Created by: Tom Jacobs
//	Created Date: Friday, September 7, 2018


METHOD AckAll
VAR_INPUT
END_VAR
VAR
	Cast : IFault;
	Fault : IFault;
	J : UINT;
END_VAR
// For each active fault in the array, ack it.
FOR J:= 0 TO _TotalObj - 1 DO
	IF (__QUERYINTERFACE(Collection[J], Cast)) THEN
		Cast.Ack();
	ELSE 
		RETURN;
	END_IF
END_FOR

METHOD AddObject
VAR_INPUT
	Obj   : IFault;
END_VAR
VAR
	I   : UINT;
	J : UINT;
END_VAR
// Add the active fault to the array 
FOR J:= 0 TO _TotalObj DO
	IF Collection[J] = Obj THEN
		// object pointer matches - it's already in here
		RETURN;
	END_IF
END_FOR
   
IF _TotalObj < GlobalObjects.MAX_FAULTS THEN
	Collection[_TotalObj]:= Obj;
	ObjNames[_TotalObj]:= Obj.InstanceName;
	_TotalObj:= _TotalObj + 1;
ELSE
	_ArrayOver:= TRUE;
	_OverObj:= _OverObj + 1;
END_IF
GlobalObjects.CollectionOfFaults.FaultUpdateForHMI();
faultActive := TRUE;

METHOD RemoveObject
VAR_INPUT
	Obj   : IFault;
END_VAR

VAR
	I   : UINT;
	J : UINT;
END_VAR

FOR I:= 0 TO _TotalObj DO
	IF Collection[I] = Obj THEN
		// object pointer matches - get rid of it
		FOR J := I TO _TotalObj DO
			Collection[J] := Collection[J+1];
			ObjNames[J]:= ObjNames[J+1]; 
		END_FOR
		_TotalObj := _TotalObj - 1;
		IF _TotalObj = 0 THEN
			GlobalObjects.CollectionOfFaults.FaultUpdateForHMI();
			faultActive := FALSE;
		END_IF
		RETURN;
	END_IF
END_FOR



FUNCTION_BLOCK FB_CollectionHandlerActiveFaults
VAR_INPUT
END_VAR
VAR
	Collection: ARRAY[0..GlobalObjects.MAX_FAULTS] OF IFault; // object array
	ObjNames   : ARRAY[0..GlobalObjects.MAX_FAULTS] OF STRING;
	_ArrayOver   : BOOL;
	_BadObj      : INT;
	_DupeObj   : INT;
	_OverObj   : INT;
	_TotalObj   : UINT;
END_VAR

VAR_OUTPUT
	faultActive : BOOL;
END_VAR
//	Function Block: FB_CollectionHandlerActiveFaults
//	Description: This collection handler adds and removes active faults to an array
//				 The add and remove methods are called from FB_Fault
//	Created by: Tom Jacobs
//	Created Date: Friday, September 7, 2018


METHOD AckAll
VAR_INPUT
END_VAR
VAR
	Cast : IFault;
	Fault : IFault;
	J : UINT;
END_VAR
// For each active fault in the array, ack it.
FOR J:= 0 TO _TotalObj - 1 DO
	IF (__QUERYINTERFACE(Collection[J], Cast)) THEN
		Cast.Ack();
	ELSE 
		RETURN;
	END_IF
END_FOR

METHOD AddObject
VAR_INPUT
	Obj   : IFault;
END_VAR
VAR
	I   : UINT;
	J : UINT;
END_VAR
// Add the active fault to the array 
FOR J:= 0 TO _TotalObj DO
	IF Collection[J] = Obj THEN
		// object pointer matches - it's already in here
		RETURN;
	END_IF
END_FOR
   
IF _TotalObj < GlobalObjects.MAX_FAULTS THEN
	Collection[_TotalObj]:= Obj;
	ObjNames[_TotalObj]:= Obj.InstanceName;
	_TotalObj:= _TotalObj + 1;
ELSE
	_ArrayOver:= TRUE;
	_OverObj:= _OverObj + 1;
END_IF
GlobalObjects.CollectionOfFaults.FaultUpdateForHMI();
faultActive := TRUE;

METHOD RemoveObject
VAR_INPUT
	Obj   : IFault;
END_VAR

VAR
	I   : UINT;
	J : UINT;
END_VAR

FOR I:= 0 TO _TotalObj DO
	IF Collection[I] = Obj THEN
		// object pointer matches - get rid of it
		FOR J := I TO _TotalObj DO
			Collection[J] := Collection[J+1];
			ObjNames[J]:= ObjNames[J+1]; 
		END_FOR
		_TotalObj := _TotalObj - 1;
		IF _TotalObj = 0 THEN
			GlobalObjects.CollectionOfFaults.FaultUpdateForHMI();
			faultActive := FALSE;
		END_IF
		RETURN;
	END_IF
END_FOR



FUNCTION_BLOCK FB_CollectionHandlerActiveFaults
VAR_INPUT
END_VAR
VAR
	Collection: ARRAY[0..GlobalObjects.MAX_FAULTS] OF IFault; // object array
	ObjNames   : ARRAY[0..GlobalObjects.MAX_FAULTS] OF STRING;
	_ArrayOver   : BOOL;
	_BadObj      : INT;
	_DupeObj   : INT;
	_OverObj   : INT;
	_TotalObj   : UINT;
END_VAR

VAR_OUTPUT
	faultActive : BOOL;
END_VAR
//	Function Block: FB_CollectionHandlerActiveFaults
//	Description: This collection handler adds and removes active faults to an array
//				 The add and remove methods are called from FB_Fault
//	Created by: Tom Jacobs
//	Created Date: Friday, September 7, 2018


METHOD AckAll
VAR_INPUT
END_VAR
VAR
	Cast : IFault;
	Fault : IFault;
	J : UINT;
END_VAR
// For each active fault in the array, ack it.
FOR J:= 0 TO _TotalObj - 1 DO
	IF (__QUERYINTERFACE(Collection[J], Cast)) THEN
		Cast.Ack();
	ELSE 
		RETURN;
	END_IF
END_FOR

METHOD AddObject
VAR_INPUT
	Obj   : IFault;
END_VAR
VAR
	I   : UINT;
	J : UINT;
END_VAR
// Add the active fault to the array 
FOR J:= 0 TO _TotalObj DO
	IF Collection[J] = Obj THEN
		// object pointer matches - it's already in here
		RETURN;
	END_IF
END_FOR
   
IF _TotalObj < GlobalObjects.MAX_FAULTS THEN
	Collection[_TotalObj]:= Obj;
	ObjNames[_TotalObj]:= Obj.InstanceName;
	_TotalObj:= _TotalObj + 1;
ELSE
	_ArrayOver:= TRUE;
	_OverObj:= _OverObj + 1;
END_IF
GlobalObjects.CollectionOfFaults.FaultUpdateForHMI();
faultActive := TRUE;

METHOD RemoveObject
VAR_INPUT
	Obj   : IFault;
END_VAR

VAR
	I   : UINT;
	J : UINT;
END_VAR

FOR I:= 0 TO _TotalObj DO
	IF Collection[I] = Obj THEN
		// object pointer matches - get rid of it
		FOR J := I TO _TotalObj DO
			Collection[J] := Collection[J+1];
			ObjNames[J]:= ObjNames[J+1]; 
		END_FOR
		_TotalObj := _TotalObj - 1;
		IF _TotalObj = 0 THEN
			GlobalObjects.CollectionOfFaults.FaultUpdateForHMI();
			faultActive := FALSE;
		END_IF
		RETURN;
	END_IF
END_FOR

